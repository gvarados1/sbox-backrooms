<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Sandbox.Game</name>
    </assembly>
    <members>
        <member name="T:Sandbox.GameAssemblyManager">
            <summary>
            Handles the storage and loading of assemblies sent from the server via string tables
            </summary>
        </member>
        <member name="P:Sandbox.GameAssemblyManager.Hash">
            <summary>
            This is a hash of loaded assembly names. We can use it to make sure we're using
            the same code as the server. This is important when it comes to things like decoding
            network messages and datatables - because if the code is different we're going to 
            get errors, because it could expect different data.
            </summary>
        </member>
        <member name="M:Sandbox.GameAssemblyManager.Init">
            <summary>
            Called on Game Loop Init
            </summary>
        </member>
        <member name="M:Sandbox.GameAssemblyManager.ClientSignonFull">
            <summary>
            The client has ended the loading and downloading session and is now ready to enter the server
            </summary>
        </member>
        <member name="M:Sandbox.GameAssemblyManager.Shutdown">
            <summary>
            Called on Game Loop Deactivate
            </summary>
        </member>
        <member name="M:Sandbox.GameAssemblyManager.OnAssemblyFromServer(System.Int32)">
            <summary>
            Called by the string table when an assembly is recieved/added
            </summary>
        </member>
        <member name="M:Sandbox.GameAssemblyManager.TestAccessControl(System.IO.Stream,System.Collections.Generic.List{System.String})">
            <summary>
            Make sure we should be able to load this dll
            </summary>
        </member>
        <member name="M:Sandbox.GameAssemblyManager.OnAssembly(System.String,System.IO.Stream,System.IO.Stream)">
            <summary>
            Assembly is ready to load. Will return false on fail.
            </summary>
        </member>
        <member name="M:Sandbox.GameAssemblyManager.ForceLoadCompiler(Sandbox.Compiler,System.Collections.Generic.List{System.String})">
            <summary>
            Called by the menu to load its dlls
            </summary>
        </member>
        <member name="M:Sandbox.GameAssemblyManager.UpdateHash">
            <summary>
            Update the hash, based on loaded assemblies.
            </summary>
        </member>
        <member name="T:Sandbox.GameLoadContext">
            <summary>
            This context is used to load the assemblies that are compiled as addons.
            We use this because it inherits from this sandbox.game context - so any dlls
            that are referenced will be passed down as the right instance.
            </summary>
        </member>
        <member name="P:Sandbox.Asset.Path">
            <summary>
            Full path to the asset
            </summary>
        </member>
        <member name="P:Sandbox.Asset.Name">
            <summary>
            Name of the asset, usually comes from the filename
            </summary>
        </member>
        <member name="M:Sandbox.Asset.PostLoad">
            <summary>
            Called when the asset is first loaded from disk.
            </summary>
        </member>
        <member name="M:Sandbox.Asset.PostReload">
            <summary>
            Called when the asset is recompiled/reloaded from disk.
            </summary>
        </member>
        <member name="T:Sandbox.SoundEvent">
            <summary>
            A sound event.
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.UI">
            <summary>
            Is this sound 2D?
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.Volume">
            <summary>
            How loud the sound should be.
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.VolumeRandom">
            <summary>
            How much to vary the volume by.
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.Pitch">
            <summary>
            The base pitch of the sound.
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.PitchRandom">
            <summary>
            How much to vary the pitch by
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.DistanceMax">
            <summary>
            The furthest away to hear this sound.
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.Sounds">
            <summary>
            A random sound from the list will be selected to be played.
            </summary>
        </member>
        <member name="P:Sandbox.SoundEvent.SelectionMode">
            <summary>
            Selection strategy to use when picking from multiple sounds.
            </summary>
        </member>
        <member name="M:Sandbox.SoundEvent.PostLoad">
            <summary>
            Called after the asset is loaded from disk
            </summary>
        </member>
        <member name="T:Sandbox.Surface">
            <summary>
            A physics surface. This is applied to each <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see> and controls its physical properties and physics related sounds.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.BaseSurface">
            <summary>
            Filepath of the base surface. Use <see cref="M:Sandbox.Surface.SetBaseSurface(System.String)">SetBaseSurface</see> and <see cref="M:Sandbox.Surface.GetBaseSurface">GetBaseSurface</see>.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.Description">
            <summary>
            A concise description explaining what this surface property should be used for.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.ImpactEffectData.Regular">
            <summary>
            Spawn one of these particles on impact.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.ImpactEffectData.Bullet">
            <summary>
            Spawn one of these particles when hit by a bullet.
            </summary>
        </member>
        <member name="P:Sandbox.Surface.ImpactEffectData.BulletDecal">
            <summary>
            Use one of these as the bullet impact decal.
            </summary>
        </member>
        <member name="M:Sandbox.Surface.FindByIndex(System.Int32)">
            <summary>
            Find a surface by its index in the array. This is the fastest way to lookup, so it's
            passed from things like Traces since the index is going to be the same. It's important to
            know that this index shouldn't be saved or networked because it could differ between loads or clients.
            Instead send the name hash and look up using that.
            </summary>
        </member>
        <member name="M:Sandbox.Surface.FindByName(System.String)">
            <summary>
            Returns a Surface from its name, or null
            </summary>
            <param name="name">The name of a surface property to look up</param>
            <returns>The surface with given name, or null if such surface property doesn't exist</returns>
        </member>
        <member name="T:Sandbox.Library">
            <summary>
            Allows the registration/creation of classes by name, in a generic way.
            Also remembers class by assembly name, so we can gracefully handle hotloading.
            </summary>
        </member>
        <member name="M:Sandbox.Library.AddAssembly(System.Reflection.Assembly,System.Type[])">
            <summary>
            Called on all loaded assemblies to gather classes with ClassLibrary attributes
            </summary>
        </member>
        <member name="M:Sandbox.Library.ProcessType(System.Type,System.Reflection.Assembly)">
            <summary>
            Process this type, add it to the library if it has the right tags
            </summary>
        </member>
        <member name="M:Sandbox.Library.EnrollType(System.Type,System.Reflection.Assembly,Sandbox.LibraryAttribute)">
            <summary>
            Should this class be automatically added to the class library, even if it isn't tagged with an attribute
            </summary>
        </member>
        <member name="M:Sandbox.Library.ShouldAutomaticallyEnrollType(System.Type)">
            <summary>
            Should this class be automatically added to the class library, even if it isn't tagged with an attribute
            </summary>
        </member>
        <member name="M:Sandbox.Library.RemoveAssembly(System.Reflection.Assembly)">
            <summary>
            Called when an assembly is being removed
            </summary>
        </member>
        <member name="M:Sandbox.Library.Create``1(System.String,System.Boolean)">
            <summary>
            Create a class by name. Will return null if class is wrong type or not found.
            </summary>
        </member>
        <member name="M:Sandbox.Library.TryCreate``1(System.Int32)">
            <summary>
            Create a class by identifier. Will return null if class is wrong type or not found.
            </summary>
        </member>
        <member name="M:Sandbox.Library.Create``1(System.Type)">
            <summary>
            Create a class by type. Will return null if class is wrong type or not found.
            </summary>
        </member>
        <member name="M:Sandbox.Library.GetAll">
            <summary>
            Returns all class registrations.
            </summary>
        </member>
        <member name="M:Sandbox.Library.GetAll``1">
            <summary>
            Get all types that are derived from type
            </summary>
        </member>
        <member name="M:Sandbox.Library.GetAttribute(System.String)">
            <summary>
            Find an attribute from a name
            </summary>
        </member>
        <member name="M:Sandbox.Library.GetAllAttributes``1">
            <summary>
            Get all library attributes that are attached to type
            </summary>
        </member>
        <member name="M:Sandbox.Library.GetAttributes``1">
            <summary>
            Get custom attributes that are derived from type
            </summary>
        </member>
        <member name="M:Sandbox.Library.Get``1(System.String)">
            <summary>
            Given the name and base type, return the type (or null if it doesn't exist)
            </summary>
        </member>
        <member name="M:Sandbox.Library.Exists``1(System.String)">
            <summary>
            Returns true if this type exists
            </summary>
        </member>
        <member name="M:Sandbox.Library.GetAttribute(System.Type)">
            <summary>
            Returns all class registrations.
            </summary>
        </member>
        <member name="M:Sandbox.Library.GetType(System.String)">
            <summary>
            Returns the Type associated with given library name, or null.
            </summary>
        </member>
        <member name="T:Sandbox.LibraryClass">
            <summary>
            Every class that is derived from this is automatically added to the library. 
            If they have a [Library] attribute we use that, if not we create an empty one.
            </summary>
        </member>
        <member name="P:Sandbox.LibraryClass.LibraryClassIdentifier">
            <summary>
            This is an int representing this class. It can be used with Library to
            get the class type. It's also networkable, so can represent the class
            type over the network.
            </summary>
        </member>
        <member name="P:Sandbox.LibraryClass.ClassInfo">
            <summary>
            We really shouldn't be using the attribute for this, it feels kind of dumb
            </summary>
        </member>
        <member name="M:Sandbox.LibraryClass.SetProperty(System.String,System.String)">
            <summary>
            Sets a property on this class. For a property to be settable you should have marked it with [Property] (or one of its children)
            </summary>
        </member>
        <member name="P:Sandbox.Voice.Enabled">
            <summary>
            Do we want to send our mic input to server?
            </summary>
        </member>
        <member name="P:Sandbox.Voice.Loopback">
            <summary>
            Do we want to play back our own voice?
            </summary>
        </member>
        <member name="P:Sandbox.Voice.SampleRate">
            <summary>
            Available clientside, this is the sample rate that we're encoding our voice at
            </summary>
        </member>
        <member name="P:Sandbox.Voice.IsRecording">
            <summary>
            Returns true if your voice is actually recording. This means you're pressing your PTT key (or have always talk on)
            and you're actually making noise that is being recorded and sent to other computers.
            </summary>
        </member>
        <member name="M:Sandbox.Voice.Decode(System.Span{System.Byte},System.Span{System.Byte})">
            <summary>
            Decode the passed data. Returns true on success and gives out a data and size.
            </summary>
        </member>
        <member name="M:Sandbox.Voice.Play(System.Int64,System.Span{System.Byte},System.Boolean)">
            <summary>
            Play this voice data
            </summary>
        </member>
        <member name="M:Sandbox.Voice.ComputeVoiceLevel(System.Int16*,System.Int32)">
            <summary>
            Go through the data and try to work out the voice level
            </summary>
        </member>
        <member name="M:Sandbox.Voice.PlayVoiceInternal(System.Span{System.Byte},System.Int64)">
            <summary>
            Actually send the voice data to the engine for playback.
            </summary>
        </member>
        <member name="P:Sandbox.ConsoleSystem.Caller">
            <summary>
            Returns the player who is calling the command. This will be null
            if the command is being called via rcon, or triggered directly
            on the server.
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.HasCallerGotPermission">
            <summary>
            Does this player have permission to do run commands that need permission
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.Build(System.String,System.Object[])">
            <summary>
            Given a command and parameters, build a coherent command
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.FindManagedValue(System.String,System.String)">
            <summary>
            Find a managed convar value
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.SetValue(System.String,System.Object)">
            <summary>
            Used by [SetValue] etc
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.GetValue(System.String,System.String)">
            <summary>
            Get a convar value as a string
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.AddAssembly(System.Reflection.Assembly)">
            <summary>
            Add this assembly to the console library, which will scan it for console commands and make them available.
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.AddConVar(Sandbox.GameConVar)">
            <summary>
            Add this convar to the library. Any existing commands named the same will be over-written.
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.RemoveAssembly(System.Reflection.Assembly)">
            <summary>
            Remove this assembly and its console commands 
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.AddCommand(Sandbox.Command)">
            <summary>
            Add this command to the library. Any existing commands named the same will be over-written.
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.RunInternal(Sandbox.ConsoleCommand)">
            <summary>
            Actually do the business of trying to run a command. Will return (not throw) an exception
            object if an exception is thrown of command isn't found.
            </summary>
        </member>
        <member name="M:Sandbox.ConsoleSystem.RunCommandFromInputBuffer(System.String)">
            <summary>
            A command has come from a key bind. Return false if we don't handle it.
            </summary>
        </member>
        <member name="M:Sandbox.ContextInterface.OnShutdown">
            <summary>
            The current game has shut down
            </summary>
        </member>
        <member name="M:Sandbox.ContextInterface.InitGamemodeData(System.String)">
            <summary>
            Create the data folders and the basefilesystem's for the gamemode folder
            </summary>
        </member>
        <member name="M:Sandbox.Internal.Decals.RemoveFromWorld">
            <summary>
            Remove all decals from the world
            </summary>
        </member>
        <member name="M:Sandbox.Internal.Decals.RemoveFromEntities">
            <summary>
            Remove all decals from entities
            </summary>
        </member>
        <member name="M:Sandbox.Internal.EntityComponentAccessor.Add``1(``0)">
            <summary>
            Add a component to this entity
            </summary>
        </member>
        <member name="M:Sandbox.Internal.EntityComponentAccessor.Remove(Sandbox.EntityComponent)">
            <summary>
            Remove a component to this entity
            </summary>
        </member>
        <member name="M:Sandbox.Internal.EntityComponentAccessor.RemoveAll">
            <summary>
            Remove all components to this entity
            </summary>
        </member>
        <member name="M:Sandbox.Internal.EntityComponentAccessor.Get``1(System.Boolean)">
            <summary>
            Get a component by type, if it exists
            </summary>
        </member>
        <member name="M:Sandbox.Internal.EntityComponentAccessor.TryGet``1(``0@,System.Boolean)">
            <summary>
            Returns true if component was found, else false
            </summary>
        </member>
        <member name="M:Sandbox.Internal.EntityComponentAccessor.GetAll``1(System.Boolean)">
            <summary>
            Get all components by type, if any exist
            </summary>
        </member>
        <member name="M:Sandbox.Internal.EntityComponentAccessor.GetOrCreate``1(System.Boolean)">
            <summary>
            Get the component, create if it doesn't exist. Will include disabled components in search.
            </summary>
        </member>
        <member name="M:Sandbox.Internal.EntityComponentAccessor.Create``1(System.Boolean)">
            <summary>
            Create the component
            </summary>
        </member>
        <member name="M:Sandbox.Internal.EntityComponentAccessor.GetAt(System.Int32)">
            <summary>
            Get component at a specific index
            </summary>
        </member>
        <member name="M:Sandbox.Internal.EntityComponentAccessor.SetAt(System.Int32,Sandbox.EntityComponent)">
            <summary>
            Set component at a specific index
            </summary>
        </member>
        <member name="T:Sandbox.Internal.EntityTags">
            <summary>
            Entity Tags are strings you can set and check for on any entity. Internally
            these strings are tokenized and networked so they're also available clientside.
            </summary>
        </member>
        <member name="P:Sandbox.Internal.EntityTags.List">
            <summary>
            Returns all the tags this entity has. We can't let you modify the HashSet directly
            because we need to keep in sync with an engine version.
            </summary>
        </member>
        <member name="M:Sandbox.Internal.EntityTags.Has(System.String)">
            <summary>
            Returns true if this entity has given tag.
            </summary>
        </member>
        <member name="M:Sandbox.Internal.EntityTags.HasAny(System.Collections.Generic.HashSet{System.String})">
            <summary>
            Returns true if this entity has one or more tags from given tag list.
            </summary>
        </member>
        <member name="M:Sandbox.Internal.EntityTags.Add(System.String)">
            <summary>
            Try to add the tag to this entity.
            </summary>
        </member>
        <member name="M:Sandbox.Internal.EntityTags.Add(System.String[])">
            <summary>
            Adds multiple tags. Calls <see cref="M:Sandbox.Internal.EntityTags.Add(System.String)">EntityTags.Add</see> for each tag.
            </summary>
        </member>
        <member name="M:Sandbox.Internal.EntityTags.Remove(System.String)">
            <summary>
            Try to remove the tag from this entity.
            </summary>
        </member>
        <member name="M:Sandbox.Internal.EntityTags.Set(System.String,System.Boolean)">
            <summary>
            Removes or adds a tag based on the second argument.
            </summary>
        </member>
        <member name="M:Sandbox.Internal.EntityTags.Toggle(System.String)">
            <summary>
            Removes a tag if it exists, adds it overwise.
            </summary>
        </member>
        <member name="T:Sandbox.Internal.EntityHandle`1">
            <summary>
            This is how entities are networked via NetworkAtomic. You can access this like a normal entity.
            The downside is that each time you "get" the entity it's a FindByIndex. Which sucks. So I might roll this back.
            </summary>
        </member>
        <member name="M:Sandbox.Internal.SpawnFlagAccessor.Has``1(``0)">
            <summary>
            Return true if entity has this spawngflag
            </summary>
        </member>
        <member name="P:Sandbox.Internal.Globals.Global.InGame">
            <summary>
            Return true if we're in a game (ie, not in the main menu)
            </summary>
        </member>
        <member name="P:Sandbox.Internal.Globals.Global.IsToolsMode">
            <summary>
            Returns true if the game is running with tools enabled
            </summary>
        </member>
        <member name="P:Sandbox.Internal.Globals.Global.IsClosing">
            <summary>
            Set to true when the game is closing
            </summary>
        </member>
        <member name="P:Sandbox.Internal.Globals.Global.TickRate">
            <summary>
            Amount of ticks to perform per second. Higher is smoother and more accurate but uses more
            power. Lower can be laggy and weird things can happen. Default is 60. This should only be
            set serverside in your game's constructor or Spawn method. It should not be changed mid-game.
            </summary>
        </member>
        <member name="P:Sandbox.Internal.Globals.Global.TickInterval">
            <summary>
            1 / TickRate
            </summary>
        </member>
        <member name="P:Sandbox.Internal.Globals.Global.PhysicsSubSteps">
            <summary>
            If you're seeing objects go through other objects or you have a low tickrate, you might
            want to increase the number of physics substeps. This breaks physics steps down into this 
            many substeps. The default is 1 and works pretty good.
            Be aware that the number of physics ticks per second is going to be tickrate * substeps. So 
            if you're ticking at 90 and you have SubSteps set to 1000 then you're going to do 90,000 steps 
            per second. So be careful here.
            </summary>
        </member>
        <member name="P:Sandbox.Internal.Globals.Global.PhysicsTimeScale">
            <summary>
            How fast (or slow) the physics should run.
            </summary>
        </member>
        <member name="P:Sandbox.Internal.Globals.Global.TimeScale">
            <summary>
            Scale the time, globally
            </summary>
        </member>
        <member name="P:Sandbox.Internal.Globals.Global.IsRunningInVR">
            <summary>
            Return true if we're running in Vr. Will always be false serverside.
            </summary>
        </member>
        <member name="P:Sandbox.Internal.Globals.Global.IsRunningOnHandheld">
            <summary>
            Return true if we're running on a handheld device (the deck). Will always be false serverside.
            </summary>
        </member>
        <member name="P:Sandbox.Internal.Globals.Global.Lobby">
            <summary>
            The server lobby. This is used for server configuration, persistence. It's possible
            to make a game that uses the lobby for communicating with other players.
            </summary>
        </member>
        <member name="P:Sandbox.Internal.Globals.Global.HotloadManager">
            <summary>
            The manager of our hotload
            </summary>
        </member>
        <member name="M:Sandbox.Internal.Globals.Global.ChangeLevel(System.String)">
            <summary>
            Change the currently loaded level. This is serverside only.
            </summary>
        </member>
        <member name="M:Sandbox.Internal.Globals.DebugOverlay.Skeleton(Sandbox.Entity,Color,System.Single,System.Boolean)">
            <summary>
            Draw this entity's skeleton ( if it has one)
            Will return false if it didn't manage to draw a skeleton.
            </summary>
        </member>
        <member name="M:Sandbox.Internal.Globals.DebugOverlay.Box(Sandbox.Entity,Color,System.Single)">
            <summary>
            Draw an entity bounds
            </summary>
        </member>
        <member name="M:Sandbox.Internal.Globals.DebugOverlay.Box(Sandbox.PhysicsBody,Color,System.Single)">
            <summary>
            Draw a physics object bounds
            </summary>
        </member>
        <member name="M:Sandbox.Internal.Globals.DebugOverlay.TraceResult(Sandbox.TraceResult,System.Single)">
            <summary>
            Visulalize a trace
            </summary>
        </member>
        <member name="T:Sandbox.Internal.VarGeneric`1">
            <summary>
            A class, or a string. Anything that NetRead/NetWrite can deal with.
            </summary>
        </member>
        <member name="T:Sandbox.Internal.VarUnmanaged`1">
            <summary>
            A fixed size Plain Old Data variable. Can be a built in type or a struct.
            </summary>
        </member>
        <member name="T:Sandbox.Internal.VarUnmanagedNullable`1">
            <summary>
            A fixed size Play Old Data variable. Can be a built in type or a struct.
            </summary>
        </member>
        <member name="T:Sandbox.Internal.VarComponent">
            <summary>
            Transfers an EntityComponent
            </summary>
        </member>
        <member name="M:Sandbox.Internal.VarComponentList.CreateVariableFromSlot(System.Int32)">
            <summary>
            Create the right type of variable
            </summary>
        </member>
        <member name="M:Sandbox.Internal.VarComponentList.OnVariableAdded(Sandbox.Internal.Var)">
            <summary>
            A variable has been added. The slot is right. We can read it here and do stuff with the result.
            </summary>
        </member>
        <member name="M:Sandbox.Internal.VarComponentList.OnVariableRemoved(Sandbox.Internal.Var)">
            <summary>
            A variable has been removed. We can get the value here and do stuff with the result.
            </summary>
        </member>
        <member name="T:Sandbox.Internal.VarContainer">
            <summary>
            A network variable that points to a bunch of other variables
            </summary>
        </member>
        <member name="T:Sandbox.Internal.VarEmbedList`1">
            <summary>
            A list of anything readable/writable with NetRead/NetWrite
            </summary>
        </member>
        <member name="M:Sandbox.Internal.VarEmbedList`1.CreateVariableFromSlot(System.Int32)">
            <summary>
            Create the right type of variable
            </summary>
        </member>
        <member name="M:Sandbox.Internal.VarEmbedList`1.OnVariableAdded(Sandbox.Internal.Var)">
            <summary>
            A variable has been added. The slot is right. We can read it here and do stuff with the result.
            </summary>
        </member>
        <member name="M:Sandbox.Internal.VarEmbedList`1.OnVariableRemoved(Sandbox.Internal.Var)">
            <summary>
            A variable has been removed. We can get the value here and do stuff with the result.
            </summary>
        </member>
        <member name="T:Sandbox.Internal.VarObjectDictionary`1">
            <summary>
            A dictionary of atomic types
            </summary>
        </member>
        <member name="T:Sandbox.Internal.VarGenericList`1">
            <summary>
            A list of anything readable/writable with NetRead/NetWrite
            </summary>
        </member>
        <member name="T:Sandbox.Internal.VarUnmanagedList`1">
            <summary>
            A list of atomic types
            </summary>
        </member>
        <member name="M:Sandbox.Internal.Var.DoWrite">
            <summary>
            This is what's called when the variable is to be written to native memory.
            This is a single entry point so we can ignore the write is the variable is
            invalid, without doing these checks in other classes.
            </summary>
        </member>
        <member name="M:Sandbox.Internal.Var.Build">
            <summary>
            Look at current value and 
            build any child variables if needed
            </summary>
        </member>
        <member name="P:Sandbox.Internal.Var.IsDirty">
            <summary>
            This variable has pending changes, waiting to be written to network. This
            variable stops dirty variables being added to the write list twice.
            </summary>
        </member>
        <member name="M:Sandbox.Internal.Var.SetDirty(System.Boolean)">
            <summary>
            Mark this variable as dirty. Its contents have changed and it needs writing
            </summary>
        </member>
        <member name="M:Sandbox.Internal.Var.AddToWriteList">
            <summary>
            Add this variable to the write list
            </summary>
        </member>
        <member name="M:Sandbox.Internal.Var.WriteAll">
            <summary>
            Write all the variables that are queued waiting to write.
            This writes them to c++ network system, it doesn't actually send them.
            </summary>
        </member>
        <member name="M:Sandbox.Internal.Var.ClearWriteList">
            <summary>
            Clear the list, we don't want to be processing this shit in the next session
            </summary>
        </member>
        <member name="T:Sandbox.Internal.UI.TextPanel">
            <summary>
            This is a simple text element. It's purely used to render text.
            It shouldn't have padding etc applied to it.
            </summary>
        </member>
        <member name="P:Sandbox.Internal.UI.TextPanel.Selectable">
            <summary>
            Can be selected
            </summary>
        </member>
        <member name="F:Sandbox.ParticleAttachment.Invalid">
            <summary>
            Invalid particle attachment type.
            </summary>
        </member>
        <member name="T:Sandbox.Particles">
            <summary>
            A particle system.
            </summary>
        </member>
        <member name="M:Sandbox.Particles.Create(System.String)">
            <summary>
            Create a particle system by name
            </summary>
        </member>
        <member name="M:Sandbox.Particles.Create(System.String,Vector3)">
            <summary>
            Create a particle system by name at a world position
            </summary>
        </member>
        <member name="M:Sandbox.Particles.Create(System.String,Sandbox.Entity,System.Boolean)">
            <summary>
            Create a particle system by name tied to an entity
            </summary>
        </member>
        <member name="M:Sandbox.Particles.Create(System.String,Sandbox.Entity,System.String,System.Boolean)">
            <summary>
            Create a particle system by name tied to an attachment on an entity
            </summary>
        </member>
        <member name="M:Sandbox.Particles.Dispose">
            <summary>
            Dispose of this particle system
            </summary>
        </member>
        <member name="M:Sandbox.Particles.Destroy(System.Boolean)">
            <summary>
            Destroy this particle system
            </summary>
        </member>
        <member name="M:Sandbox.Particles.SetPosition(System.Int32,Vector3)">
            <summary>
            Set control point data as a position vector
            </summary>
        </member>
        <member name="M:Sandbox.Particles.SetPositionComponent(System.Int32,System.Int32,System.Single)">
            <summary>
            Set a single component of a given control point's position
            </summary>
        </member>
        <member name="M:Sandbox.Particles.SetOrientation(System.Int32,Angles)">
            <summary>
            Set control point data as an orientation
            </summary>
        </member>
        <member name="M:Sandbox.Particles.SetOrientation(System.Int32,Rotation)">
            <summary>
            Set control point data as an orientation. Converts Rotation to Angles for you.
            </summary>
        </member>
        <member name="M:Sandbox.Particles.SetForward(System.Int32,Vector3)">
            <summary>
            Set control point data as a direction vector
            </summary>
        </member>
        <member name="M:Sandbox.Particles.SetEntity(System.Int32,Sandbox.Entity,System.Boolean)">
            <summary>
            Set the control point to an entity's origin. Can specify whether to follow or not.
            </summary>
        </member>
        <member name="M:Sandbox.Particles.SetEntity(System.Int32,Sandbox.Entity,Vector3,System.Boolean)">
            <summary>
            Set the control point to an entity's origin offset by the local offset.
            </summary>
        </member>
        <member name="M:Sandbox.Particles.SetEntityAttachment(System.Int32,Sandbox.Entity,System.String,System.Boolean)">
            <summary>
            Set the control point to an entity's attachment position. Can specify whether to follow or not.
            </summary>
        </member>
        <member name="M:Sandbox.Particles.SetEntityAttachment(System.Int32,Sandbox.Entity,System.String,Vector3,Sandbox.ParticleAttachment)">
            <summary>
            Set the control point to an entity's attachment position with an offset and custom attachment type.
            </summary>
        </member>
        <member name="M:Sandbox.Particles.SetEntityBone(System.Int32,Sandbox.Entity,System.Int32,Transform,System.Boolean)">
            <summary>
            Set the control point to an entity's bone position. Can specify whether to follow or not.
            </summary>
        </member>
        <member name="M:Sandbox.Particles.SetModel(System.Int32,Sandbox.Model)">
            <summary>
            Sets the model of the control point.
            </summary>
        </member>
        <member name="M:Sandbox.Particles.SetSnapshot(System.Int32,System.String)">
            <summary>
            Sets the particle snapshot by asset name.
            </summary>
        </member>
        <member name="P:Sandbox.Sound.Listener">
            <summary>
            Set an override for the position and rotation of the local client's audio listener
            </summary>
        </member>
        <member name="P:Sandbox.Sound.ElapsedTime">
            <summary>
            Return the elapsed time from the start of the sound in seconds
            </summary>
        </member>
        <member name="P:Sandbox.Sound.Finished">
            <summary>
            Returns if a song has finished playing
            </summary>
        </member>
        <member name="M:Sandbox.Sound.FromWorld(System.String,Vector3)">
            <summary>
            Create a sound originating from a world position
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Sound.FromEntity(System.String,Sandbox.Entity)">
            <summary>
            Create a sound originating from an entity
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Sound.FromScreen(System.String,System.Single,System.Single)">
            <summary>
            Create a sound originating from screen coordinates
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Sound.Stop">
            <summary>
            Stop the sound from playing
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Sound.SetVolume(System.Single)">
            <summary>
            Set the volume of the sound
            </summary>
            <param name="volume"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Sound.SetPitch(System.Single)">
            <summary>
            Set pitch value (Note: this is always executed and is multiplied with the initial random pitch)
            </summary>
        </member>
        <member name="M:Sandbox.Sound.SetRandomPitch(System.Single,System.Single)">
            <summary>
            Set random pitch value between min and max (Note: this is executed once)
            </summary>
        </member>
        <member name="M:Sandbox.Sound.SetPosition(Vector3)">
            <summary>
             Set the world position that this sounds originates from
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.EntityManager.CreateServerEntity(System.String)">
            <summary>
            The engine wants to create this entity by name.
            </summary>
        </member>
        <member name="P:Sandbox.AnimationSequence.Duration">
            <summary>
            The duration of the currently playing sequence (seconds)
            </summary>
        </member>
        <member name="P:Sandbox.AnimationSequence.IsFinished">
            <summary>
            Get whether the current animation sequence has finished
            </summary>
        </member>
        <member name="P:Sandbox.AnimationSequence.Name">
            <summary>
            The name of the currently playing animation sequence
            </summary>
        </member>
        <member name="P:Sandbox.AnimationSequence.TimeNormalized">
            <summary>
            The normalized (between 0 and 1) elapsed time of the currently playing
            animation sequence
            </summary>
        </member>
        <member name="P:Sandbox.AnimationSequence.Time">
            <summary>
            The elapsed time of the currently playing animation sequence (seconds)
            </summary>
        </member>
        <member name="P:Sandbox.AnimEntity.Sequence">
            <summary>
            The currently playing sequence/animation
            </summary>
        </member>
        <member name="P:Sandbox.AnimEntity.UseAnimGraph">
            <summary>
            Allows the entity to not use the anim graph so it can play sequences directly
            </summary>
        </member>
        <member name="M:Sandbox.AnimEntity.HasAnimGraph">
            <summary>
            Whether this entity's model has an anim graph or not
            </summary>
        </member>
        <member name="P:Sandbox.AnimEntity.PlaybackRate">
            <summary>
            Playback rate of the animations on this entity
            </summary>
        </member>
        <member name="P:Sandbox.AnimEntity.RootMotion">
            <summary>
            Experimental root motion velocity for anim graphs that use root motion
            </summary>
        </member>
        <member name="P:Sandbox.AnimEntity.RootMotionAngle">
            <summary>
            Experimental root motion angle velocity for anim graphs that use root motion
            </summary>
        </member>
        <member name="M:Sandbox.AnimEntity.GetSequenceDuration(System.String)">
            <summary>
            Get the duration of a sequence by name
            </summary>
        </member>
        <member name="M:Sandbox.AnimEntity.GetSequenceDuration">
            <summary>
            Get the duration of the currently playing sequence
            </summary>
        </member>
        <member name="M:Sandbox.AnimEntity.IsSequenceFinished">
            <summary>
            Get whether the current animation sequence has finished
            </summary>
        </member>
        <member name="M:Sandbox.AnimEntity.IsValidSequence(System.String)">
            <summary>
            Check whether a sequence is valid by name
            </summary>
        </member>
        <member name="M:Sandbox.AnimEntity.SetAnimLookAt(System.String,Vector3)">
            <summary>
            Converts value to vector local to this entity's eyepos and passes it to SetAnimVector
            </summary>
        </member>
        <member name="M:Sandbox.AnimEntity.OnNewSequence">
            <summary>
            Called when a new animation sequence is set
            </summary>
        </member>
        <member name="M:Sandbox.AnimEntity.OnSequenceFinished(System.Boolean)">
            <summary>
            Called when an animation sequence has finsihed or looped
            </summary>
            <param name="looped">If the animation was restarted rather than stopped.</param>
        </member>
        <member name="T:Sandbox.AnimEntity.AnimGraphTagEvent">
            <summary>
            Enumeration that describes how the AnimGraph tag state changed. Used in <see cref="M:Sandbox.AnimEntity.OnAnimGraphTag(System.String,Sandbox.AnimEntity.AnimGraphTagEvent)"/>.
            </summary>
        </member>
        <member name="F:Sandbox.AnimEntity.AnimGraphTagEvent.Fired">
            <summary>
            Tag was activated and deactivated on the same frame
            </summary>
        </member>
        <member name="F:Sandbox.AnimEntity.AnimGraphTagEvent.Start">
            <summary>
            The tag has become active
            </summary>
        </member>
        <member name="F:Sandbox.AnimEntity.AnimGraphTagEvent.End">
            <summary>
            The tag has become inactive
            </summary>
        </member>
        <member name="M:Sandbox.AnimEntity.OnAnimGraphTag(System.String,Sandbox.AnimEntity.AnimGraphTagEvent)">
            <summary>
            Called when the anim graph of this entity has a tag change.
            This will be called only for "Status" type tags.
            </summary>
            <param name="tag">The name of the tag that has changed its state, as it is defined in the AnimGraph.</param>
            <param name="fireMode">Describes how the state of the tag has changed.</param>
        </member>
        <member name="M:Sandbox.AnimEntity.OnAnimGraphCreated">
            <summary>
            An anim graph has been created for this entity. You will want to set up initial AnimGraph parameters here.
            </summary>
        </member>
        <member name="M:Sandbox.AnimEntity.SetAnimGraphPreview">
            <summary>
            Allow animgraph tool to use this entity as the preview, Server only
            </summary>
        </member>
        <member name="T:Sandbox.Component.Glow">
            <summary>
            A component for controlling the "glow" outline on a entity
            
            TODO: Wouldn't it be nice if this didn't even touch any engine stuff
            and we could create the scene object or whatever ourselves in a controlled
            and cleaned up way?
            
            </summary>
        </member>
        <member name="P:Sandbox.Component.Glow.Color">
            <summary>
            The colour of the glow
            </summary>
        </member>
        <member name="P:Sandbox.Component.Glow.Active">
            <summary>
            Gets or set if the glow is active on the object.
            </summary>
        </member>
        <member name="P:Sandbox.Component.Glow.RangeMin">
            <summary>
            The minimum distance that this object will start glowing.
            </summary>
        </member>
        <member name="P:Sandbox.Component.Glow.RangeMax">
            <summary>
            The maximum distance that this object will glow.
            </summary>
        </member>
        <member name="T:Sandbox.Component.NavBlocker">
            <summary>
            A static nav blocker.
            </summary>
        </member>
        <member name="F:Sandbox.NavBlockerType.AVOID">
            <summary>
            An "avoidance" obstacle. Places a height-based obstruction onto nav areas.
            </summary>
        </member>
        <member name="F:Sandbox.NavBlockerType.AREA">
            <summary>
            An obstacle that marks entire areas it intersects with as blocked.
            </summary>
        </member>
        <member name="F:Sandbox.NavBlockerType.BLOCK">
            <summary>
            An obstacle that blocks nav, possibly cutting nav or triggering dynamic generation.
            </summary>
        </member>
        <member name="T:Sandbox.Entity">
            <summary>
            A base entity all other entities derive from.
            </summary>
        </member>
        <member name="F:Sandbox.Entity.IncomingClientInstance">
            <summary>
            Set in EntityManager when creating an entity from the network.
            If null we assume the entity was just a user initiated new() and
            will create a clientside entity
            </summary>
        </member>
        <member name="P:Sandbox.Entity.IsClientOnly">
            <summary>
            Returns true if this entity is a purely clientside entity, with no serverside components
            </summary>
        </member>
        <member name="P:Sandbox.Entity.IsDormant">
            <summary>
            Returns true if this entity is dormant (the client cannot see it, it isn't being networked)
            </summary>
        </member>
        <member name="M:Sandbox.Entity.InternalOnSetDormant(System.Boolean)">
            <summary>
            The entity has entered/exited PVS and has stopped being networked
            </summary>
        </member>
        <member name="M:Sandbox.Entity.OnNetworkDormant">
            <summary>
            The entity has left the client's visibility and has stopped receiving network updates.
            When it becomes active again OnNetworkActive will be called. 
            </summary>
        </member>
        <member name="M:Sandbox.Entity.OnNetworkActive">
            <summary>
            Entity has re-entered the client's visibility and has started receiving network updates again.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.OnActive">
            <summary>
            Entity is active (clientside). This is called after spawn.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.OnComponentAdded(Sandbox.EntityComponent)">
            <summary>
            A component has been added to the entity.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.OnComponentRemoved(Sandbox.EntityComponent)">
            <summary>
            A component has been removed from the entity.
            </summary>
        </member>
        <member name="P:Sandbox.Entity.IsAuthority">
            <summary>
            Returns true if we have authority over this entity. This means we're either serverside,
            or we're a clientside entity, or we're a serverside entity being predicted on the client.
            </summary>
        </member>
        <member name="P:Sandbox.Entity.NativeEntityClass">
            <summary>
            The name of the entity to create in the entity to base this
            entity off.
            </summary>
        </member>
        <member name="F:Sandbox.Entity.Task">
            <summary>
            Allows Task.Delay calls etc that are automatically cancelled when the entity is destroyed
            </summary>
        </member>
        <member name="P:Sandbox.Entity.IsWorld">
            <summary>
            Returns true if this entity is the world
            </summary>
        </member>
        <member name="P:Sandbox.Entity.IsValid">
            <summary>
            Returns true if this entity has not been destroyed and it is valid to access its internals
            </summary>
        </member>
        <member name="P:Sandbox.Entity.IsFromMap">
            <summary>
            Returns true if this specific entity instance was spawned from the map.
            </summary>
        </member>
        <member name="P:Sandbox.Entity.Name">
            <summary>
            The entity target name. This is typically used by map IO and to generally access specific entities from code.
            </summary>
        </member>
        <member name="P:Sandbox.Entity.LocalPosition">
            <summary>
            The entity's position relative to its parent (or the world if no parent)
            </summary>
        </member>
        <member name="P:Sandbox.Entity.Position">
            <summary>
            The entity's position relative to its parent (or the world if no parent)
            </summary>
        </member>
        <member name="P:Sandbox.Entity.Rotation">
            <summary>
            The entity's world rotation
            </summary>
        </member>
        <member name="P:Sandbox.Entity.WorldAng">
            <summary>
            The entity's angle
            </summary>
        </member>
        <member name="P:Sandbox.Entity.LocalRotation">
            <summary>
            The entity's local rotation
            </summary>
        </member>
        <member name="P:Sandbox.Entity.LocalScale">
            <summary>
            The entity's local scale
            </summary>
        </member>
        <member name="P:Sandbox.Entity.Scale">
            <summary>
            The scale of the entity. 1 is normal.
            </summary>
        </member>
        <member name="P:Sandbox.Entity.Velocity">
            <summary>
            The velocity in world coords.
            </summary>
        </member>
        <member name="P:Sandbox.Entity.AngularVelocity">
            <summary>
            The angular velocity in local coords
            </summary>
        </member>
        <member name="P:Sandbox.Entity.LocalVelocity">
            <summary>
            Velocity in local coords
            </summary>
        </member>
        <member name="P:Sandbox.Entity.BaseVelocity">
            <summary>
            Generally describes the velocity of this object that is caused by its parent moving.
            Examples would be conveyor belts and elevators.
            </summary>
        </member>
        <member name="P:Sandbox.Entity.GroundEntity">
            <summary>
            Generally describes the velocity of this object that is caused by its parent moving.
            Examples would be conveyor belts and elevators.
            </summary>
        </member>
        <member name="P:Sandbox.Entity.EngineEntityName">
            <summary>
            The internal class name of this entity. For debug purposes only.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.OnHotloaded">
            <summary>
            Called when we hotload
            </summary>
        </member>
        <member name="M:Sandbox.Entity.GetEntityIntPtr">
            <summary>
            Careful and know what you're doing! This returns the raw pointer
            for the C_BaseEntity or the CBaseEntity - depending on what realm we're in
            </summary>
        </member>
        <member name="M:Sandbox.Entity.Delete">
            <summary>
            Delete this entity. You shouldn't access it anymore.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.DeleteAsync(System.Single)">
            <summary>
            Delete the entity after given delay in seconds.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.OnKilled">
            <summary>
            Called when there's no health left
            </summary>
        </member>
        <member name="M:Sandbox.Entity.ResetInterpolation">
            <summary>
            Reset the interpolation.
            You can use this so if you move an entity it doesn't lerp to the new position
            </summary>
        </member>
        <member name="M:Sandbox.Entity.SetSimulationTime(System.Single)">
            <summary>
            I don't think we need to give people access to this?
            </summary>
        </member>
        <member name="M:Sandbox.Entity.Simulate(Sandbox.Client)">
            <summary>
            Called when simulating as part of a player's tick. Like if it's a pawn.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.FrameSimulate(Sandbox.Client)">
            <summary>
            Called each frame clientside only on Pawn (and anything the pawn decides to call it on)
            </summary>
        </member>
        <member name="M:Sandbox.Entity.BuildInput(Sandbox.InputBuilder)">
            <summary>
            Pawns get a chance to mess with the input clientside
            </summary>
        </member>
        <member name="M:Sandbox.Entity.GetClientOwner">
            <summary>
            Get the client owner. This will ascend up the owner chain to find the actual owner.
            </summary>
        </member>
        <member name="P:Sandbox.Entity.Client">
            <summary>
            The client that owns this entity. Usualy as a result of being the client's Pawn.
            Also could be because the client's pawn owns this entity,
            </summary>
        </member>
        <member name="P:Sandbox.Entity.IsLocalPawn">
            <summary>
            Will return true if we're clientside, this entity has an owner and we're
            currently treating this owner as the local client. This means the player
            could be being spectated.
            </summary>
        </member>
        <member name="P:Sandbox.Entity.EyePos">
            <summary>
            Position a player should be looking from in world space.
            </summary>
        </member>
        <member name="P:Sandbox.Entity.EyePosLocal">
            <summary>
            Position a player should be looking from in local coordinates.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.RenderDirty">
            <summary>
            Mark render dirty
            </summary>
        </member>
        <member name="M:Sandbox.Entity.PostCameraSetup(Sandbox.CameraSetup@)">
            <summary>
            Allow a pawn to set up the camera
            </summary>
        </member>
        <member name="M:Sandbox.Entity.CanCarry(Sandbox.Entity)">
            <summary>
            Return false if this entity objects to being picked up by this entity
            </summary>
        </member>
        <member name="M:Sandbox.Entity.OnCarryStart(Sandbox.Entity)">
            <summary>
            Allow the entity to do what it wants when it's added to the inventory.
            Default behaviour is to add the target entity as a parent and stop moving.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.OnCarryDrop(Sandbox.Entity)">
            <summary>
            Allow the entity to do what it wants when it's removed from the inventory
            </summary>
        </member>
        <member name="P:Sandbox.Entity.WorldSpaceBounds">
            <summary>
            Axis-aligned bounding box in world space.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.OnClientActive">
            <summary>
            Called when a player becomes active
            </summary>
        </member>
        <member name="P:Sandbox.Entity.EnableDrawing">
            <summary>
            Turning this off will compleletely prevent the entity from drawing
            </summary>
        </member>
        <member name="P:Sandbox.Entity.EnableShadowCasting">
            <summary>
            Don't cast no shadow
            </summary>
        </member>
        <member name="P:Sandbox.Entity.EnableShadowReceive">
            <summary>
            Don't receive no shadow [TODO: DOESNT WORK]
            </summary>
        </member>
        <member name="P:Sandbox.Entity.EnableShadowOnly">
            <summary>
            Render Only Shadows
            </summary>
        </member>
        <member name="P:Sandbox.Entity.EnableShadowInFirstPerson">
            <summary>
            Render Shadows when hidden due to being in first person
            </summary>
        </member>
        <member name="P:Sandbox.Entity.EnableHideInFirstPerson">
            <summary>
            Hide this model when in first person, or our parent is in first person
            </summary>
        </member>
        <member name="P:Sandbox.Entity.EnableViewmodelRendering">
            <summary>
            Enable Viewmodel Rendering
            </summary>
        </member>
        <member name="P:Sandbox.Entity.EnableDrawOverWorld">
            <summary>
            similar to ignorez to draw over world but still having depth info
            </summary>
        </member>
        <member name="P:Sandbox.Entity.IsFirstPersonMode">
            <summary>
            If this entity is being viewed through, or is a child of an entity that is being view
            through - will return true. This can be read are we in first person mode.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.InternalEntityKeyValue(System.UInt32,System.String,System.Int32)">
            <summary>
            Called befre InternalSpawn for every EntityKeyValue provided - usually provided by Hammer.
            For a property to be settable from Hammer, mark it with [HammerProp]
            You can then use it to do any configuration in Spawn.
            This is serverside only! Probably!
            If the conversion to the type you want to convert to isn't supported - talk to Garry
            </summary>
        </member>
        <member name="M:Sandbox.Entity.InternalEntityConnection(System.String,NativeEngine.EntityIOTargetType,System.String,System.String,System.String,System.Single,System.Int32)">
            <summary>
            Called on entity spawn with all the Hammer set IO connections
            </summary>
        </member>
        <member name="M:Sandbox.Entity.FireOutput(System.String,Sandbox.Entity,System.Object,System.Single)">
            <summary>
            Try to fire this output
            </summary>
        </member>
        <member name="T:Sandbox.Entity.Output">
            <summary>
            A Map Logic Output, for use in the Hammer Editor.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.Output.#ctor(Sandbox.Entity,System.String)">
            <summary>
            You shouldn't really ever be initializing this manually, 
            codegen will take care of that by generating a CreateHammerOutputs method for
            each entity filled with constructors for these.
            </summary>
        </member>
        <member name="T:Sandbox.Entity.Output`1">
            <summary>
            A Map Logic Output with a typed parameter, for use in the Hammer Editor.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.Output`1.#ctor(Sandbox.Entity,System.String)">
            <summary>
            You shouldn't really ever be initializing this manually, 
            codegen will take care of that by generating a CreateHammerOutputs method for
            each entity filled with constructors for these.
            </summary>
        </member>
        <member name="P:Sandbox.Entity.Root">
            <summary>
            Gets the top most parent entity. If we don't have a parent, it might be us.
            </summary>
        </member>
        <member name="P:Sandbox.Entity.ActiveChild">
            <summary>
            Lets remove this
            </summary>
        </member>
        <member name="P:Sandbox.Entity.Owner">
            <summary>
            The entity that owns this entity
            </summary>
        </member>
        <member name="M:Sandbox.Entity.SetParent(Sandbox.Entity,System.String,System.Nullable{Transform})">
            <summary>
            Become a child of this entity and follow this attachment or bone if provided.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.SetParent(Sandbox.Entity,System.Int32,System.Nullable{Transform})">
            <summary>
            Finds the bone name and calls the other SetParent with it.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.SetParent(Sandbox.Entity,System.Boolean)">
            <summary>
            Set the parent to the passed entity
            </summary>
            <param name="entity"></param>
            <param name="boneMerge"></param>
        </member>
        <member name="M:Sandbox.Entity.IsActiveChild">
            <summary>
            Returns true if this is its parent's active child
            </summary>
        </member>
        <member name="M:Sandbox.Entity.LagCompensation">
            <summary>
            Enable lag compensation. This will rewind all eligible entities to the positions they
            were when the client sent the command that is being simulated. When used in a `using` block,
            lag compensation will be automatically finished when it is disposed.
            </summary>
        </member>
        <member name="P:Sandbox.Entity.EnableLagCompensation">
            <summary>
            Whether or not this entity will be considered for lag compensation. If this is true, the entity's collision bounds
            and any hitboxes it has will be rewound to the positions the client saw them in when sending its input command.
            </summary>
        </member>
        <member name="P:Sandbox.Entity.NetworkDictionary">
            <summary>
            Here for debug purposes
            </summary>
        </member>
        <member name="M:Sandbox.Entity.InitNetworkTables">
            <summary>
            Called on creation and hotload to initialize the network tables
            </summary>
        </member>
        <member name="P:Sandbox.Entity.NetworkIdent">
            <summary>
            Returns the entity's network id. Client only entities have a network id too!
            </summary>
        </member>
        <member name="P:Sandbox.Entity.PhysicsGroup">
            <summary>
            If this entity has multiple physics objects, a physics group lets you control them all as one.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.Touch(Sandbox.Entity)">
            <summary>
            An entity has touched this entity
            </summary>
        </member>
        <member name="M:Sandbox.Entity.StartTouch(Sandbox.Entity)">
            <summary>
            An entity has started touching this entity
            </summary>
        </member>
        <member name="M:Sandbox.Entity.EndTouch(Sandbox.Entity)">
            <summary>
            An entity has stopped touching this entity
            </summary>
        </member>
        <member name="M:Sandbox.Entity.PhysicsClear">
            <summary>
            Destroy any physics objects
            </summary>
        </member>
        <member name="P:Sandbox.Entity.Predictable">
            <summary>
            Defaults to true, this allows you to turn off prediction for this entity. If you set this
            to false then the entity won't be predicted even if it's eligible (has local client owner).
            </summary>
        </member>
        <member name="M:Sandbox.Entity.IsPredictable">
            <summary>
            Returns true if should be simulated, which means:
            
            1. This is a server entity and we're server side
            2. This is a client entity and we're client side
            3. This is a server entity, we're client side, and prediction is enabled for this entity
            </summary>
        </member>
        <member name="M:Sandbox.Entity.PredictionDataStore.StompValue(System.String,System.Object)">
            <summary>
            A prediction error has occurred, so we're forcing the values to match what came from the server
            </summary>
        </member>
        <member name="M:Sandbox.Entity.PredictionStore(System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Store our current predicted data in this slot
            </summary>
        </member>
        <member name="M:Sandbox.Entity.PredictionRestore(System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Restore our current predicted data from this slot
            </summary>
        </member>
        <member name="M:Sandbox.Entity.PredictionVerify(System.Int32,System.Int32)">
            <summary>
            We just got predicted data from the server for this command_num. 
            The server data is in slot -1
            Our stored data is in the passed slot
            They should be pretty much identical. Lets compare them and check.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.OnPredictionError(System.String,System.Object)">
            <summary>
            On prediction errors right now we're just stomping the value in the current 
            storage and any future. This could lead to a situation where the client is in
            front by a number of ticks and the value changes, it keeps flipping back.
            This should really trigger a re-simulate in the engine code. TODO.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.PredictionDestroy">
            <summary>
            Prediction ended, clean up
            </summary>
        </member>
        <member name="M:Sandbox.Entity.PredictionShift(System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="P:Sandbox.Entity.All">
            <summary>
            A list of all active entities
            </summary>
        </member>
        <member name="M:Sandbox.Entity.FindByIndex(System.Int32)">
            <summary>
            Finds an entity by its NetworkIdent
            </summary>
        </member>
        <member name="M:Sandbox.Entity.FindByName(System.String,Sandbox.Entity)">
            <summary>
            Finds entities by EntityName and returns the first found result, if one was found. This does not handle cases where there are multiple entities with a given name.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.FindAllByName(System.String)">
            <summary>
            Finds all entities by given EntityName.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.PlayerSetupVisibility(System.Int32,System.IntPtr)">
            <summary>
            Called by the server to determine what the player should see
            </summary>
        </member>
        <member name="F:Sandbox.Entity.Tags">
            <summary>
            Accessor to add, remove and check entity tags
            </summary>
        </member>
        <member name="F:Sandbox.Entity.networkTags">
            <summary>
            Tags that exist on the server and are networked down to the client
            </summary>
        </member>
        <member name="M:Sandbox.Entity.UpdateTagsFromNetwork">
            <summary>
            This is called on the client after a network update to keep the networkTags list up to date
            </summary>
        </member>
        <member name="M:Sandbox.Entity.OnTagAdded(System.String)">
            <summary>
            Called when a tag was added to this entity. On the client this will get called
            when an entity is created or enters PVS.
            </summary>
        </member>
        <member name="M:Sandbox.Entity.OnTagRemoved(System.String)">
            <summary>
            Called when a tag was removed from this entity.
            </summary>
        </member>
        <member name="T:Sandbox.TagList">
            <summary>
            A wrapped HashSet[string]. A list of strings. Used for custom Entity properties.
            </summary>
        </member>
        <member name="M:Sandbox.TagList.Set(System.String,System.Boolean)">
            <summary>
            Removes or adds a tag based on the second argument.
            </summary>
        </member>
        <member name="M:Sandbox.TagList.Toggle(System.String)">
            <summary>
            Removes a tag if it exists, adds it overwise.
            </summary>
        </member>
        <member name="M:Sandbox.EntityComponent.OnActivate">
            <summary>
            Called when this component is enabled (or added to the entity)
            </summary>
        </member>
        <member name="M:Sandbox.EntityComponent.OnDeactivate">
            <summary>
            Called when this component is disabled (or removed from the entity)
            </summary>
        </member>
        <member name="M:Sandbox.EntityComponent.CanAddToEntity(Sandbox.Entity)">
            <summary>
            Return false if can't be added to this entity for some reason
            </summary>
        </member>
        <member name="M:Sandbox.EntityComponent.Remove">
            <summary>
            Remove this component from the parent entity. Entity will become null immediately,
            so don't try to access it after calling this!
            </summary>
        </member>
        <member name="M:Sandbox.EntityComponent`1.CanAddToEntity(Sandbox.Entity)">
            <summary>
            Return false if target entity is not of type T
            </summary>
        </member>
        <member name="T:Sandbox.EntityEffects">
            <summary>
            Note - most of these aren't used
            </summary>
        </member>
        <member name="F:Sandbox.EntityEffects.HiddenInFirstPerson">
            <summary>
            Copy the parent's nodraw..
            </summary>
        </member>
        <member name="F:Sandbox.EntityEffects.DrawAsViewModel">
            <summary>
            Change the render layer to viewmodel
            </summary>
        </member>
        <member name="F:Sandbox.EntityEffects.DrawOverDepth">
            <summary>
            similar to ignorez to draw over world but still having depth info
            </summary>
        </member>
        <member name="M:Sandbox.EntityIO.Output.BuildTargets(Sandbox.Entity)">
            <summary>
            Get a list of entities that are appropriate targets for this
            </summary>
        </member>
        <member name="M:Sandbox.EntityIO.Output.ShouldSendToEntity(Sandbox.Entity)">
            <summary>
            TODO - TargetType
            </summary>
        </member>
        <member name="T:Sandbox.EnvironmentLightEntity">
            <summary>
            An environment light entity. This acts the sun.
            </summary>
        </member>
        <member name="P:Sandbox.EnvironmentLightEntity.FogStength">
            <summary>
            Overrides how much the light affects the fog. (if enabled)
            </summary>
        </member>
        <member name="T:Sandbox.FGDCurve">
            <summary>
            A helper class to handle 'curve' FGD type.
            </summary>
        </member>
        <member name="M:Sandbox.FGDCurve.Get(System.Single,System.Boolean)">
            <summary>
            The cubic spline function in ranges as defined in Hammer/Asset editor.
            </summary>
        </member>
        <member name="M:Sandbox.FGDCurve.GetNormalized(System.Single,System.Boolean)">
            <summary>
            The cubic spline function normalized to ranges [0,1] on both input and output.
            </summary>
        </member>
        <member name="P:Sandbox.FGDCurve.Mins">
            <summary>
            The bottom left corner of the curve. Mins and Maxs represet the range of inputs and outputs of the curve function.
            </summary>
        </member>
        <member name="P:Sandbox.FGDCurve.Maxs">
            <summary>
            The top right corner of the curve. Mins and Maxs represet the range of inputs and outputs of the curve function.
            </summary>
        </member>
        <member name="P:Sandbox.FGDCurve.IsValid">
            <summary>
            Whether the curve was loaded correctly or not
            </summary>
        </member>
        <member name="T:Sandbox.IUse">
            <summary>
            If an entity implements this it'll be usable by looking at it and pressing the USE button.
            </summary>
        </member>
        <member name="M:Sandbox.IUse.OnUse(Sandbox.Entity)">
            <summary>
            The (probably) player has used this entity. Return true if the player
            should continually use it. Return false when the player should stop using it.
            For example - a health charger will return true while the player is taking health.
            We're passing the player in as an entity so at some point
            if we want NPCs using shit, we can do that without the assumption.
            </summary>
        </member>
        <member name="M:Sandbox.IUse.IsUsable(Sandbox.Entity)">
            <summary>
            Should return true if the entity can use this entity.
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.SetBodyGroup(System.Int32,System.Int32)">
            <summary>
            Set body group to replace parts of the model
            Uses index for bodygroup
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.SetBodyGroup(System.String,System.Int32)">
            <summary>
            Set body group to replace parts of the model
            Uses name for bodygroup
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.CopyBodyGroups(Sandbox.ModelEntity)">
            <summary>
            Copy body groups over to this model
            </summary>
        </member>
        <member name="P:Sandbox.ModelEntity.EnableAllCollisions">
            <summary>
            Enable or disable all physics/solid collisions as well as 
            trace collisions.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEntity.EnableTouch">
            <summary>
            Allow Touch callbacks to be called
            </summary>
        </member>
        <member name="P:Sandbox.ModelEntity.EnableTouchPersists">
            <summary>
            Allow Touch callbacks to be called
            </summary>
        </member>
        <member name="P:Sandbox.ModelEntity.EnableHitboxes">
            <summary>
            Use Hitboxes for traces etc
            </summary>
        </member>
        <member name="P:Sandbox.ModelEntity.EnableSelfCollisions">
            <summary>
            Allow ragdoll parts to collide with each other
            </summary>
        </member>
        <member name="P:Sandbox.ModelEntity.SurroundingBoundsMode">
            <summary>
            Set the method used to work out the surrounding bounds. The bounds are important for 
            traces and collision checks, because they're used the quickly eliminate collisions.
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.SetInteractsAs(Sandbox.CollisionLayer)">
            <summary>
            Which interaction layers do I represent?
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.SetInteractsWith(Sandbox.CollisionLayer)">
            <summary>
            Which interaction layers do I interact or collide with?
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.SetInteractsExclude(Sandbox.CollisionLayer)">
            <summary>
            Which interaction layers do I represent?
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.SetMaterialOverride(Sandbox.Material)">
            <summary>
            Sets the scene objects material
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.SetMaterialOverride(System.String)">
            <summary>
            Sets the scene objects material
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.InternalOnNewModel">
            <summary>
            Called from engine when a new model is set
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.OnNewModel(Sandbox.Model)">
            <summary>
            Called when the model is changed.
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.TakeDecalsFrom(Sandbox.ModelEntity)">
            <summary>
            Move all of the decals from this entity onto ourself
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.OnCarryStart(Sandbox.Entity)">
            <summary>
            Allow the entity to do what it wants when it's added to the inventory.
            Default behaviour is to add the target entity as a parent and stop moving.
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.OnCarryDrop(Sandbox.Entity)">
            <summary>
            Allow the entity to do what it wants when it's removed from the inventory
            </summary>
        </member>
        <member name="P:Sandbox.ModelEntity.GlowColor">
            <summary>
            Get and set the color of the glow override on this object.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEntity.GlowState">
            <summary>
            Get and set the behaviour of the glow.
            Note that you still need to use GlowActive to enable it.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEntity.GlowActive">
            <summary>
            Gets or set if the glow is active on the object.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEntity.GlowDistanceStart">
            <summary>
            The minimum distance that this object will start glowing.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEntity.GlowDistanceEnd">
            <summary>
            The maximum distance that this object will glow.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEntity.GlowMaterial">
            <summary>
            Override the material that this object will use to glow
            </summary>
        </member>
        <member name="P:Sandbox.ModelEntity.EnableShadowCasting">
            <summary>
            Don't cast no shadow.
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.LiquidManager.Init(Sandbox.ModelEntity)">
            <summary>
            Creates a liquid manager if the model uses a liquid material
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.LiquidManager.Update(System.Nullable{Vector3})">
            <summary>
            Updates the parameters of the liquid per frame
            Can take extra aggitation besides standard physical forces as an optional parameter
            </summary>
        </member>
        <member name="P:Sandbox.ModelEntity.MaterialGroupCount">
            <summary>
            Set material group to replace materials of the model
            Uses index for material group
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.SetMaterialGroup(System.Int32)">
            <summary>
            Set material group to replace materials of the model
            Uses index for material group
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.SetMaterialGroup(System.String)">
            <summary>
            Set material group to replace materials of the model
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.CopyMaterialGroup(Sandbox.ModelEntity)">
            <summary>
            Copy material group over to this model
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.MoveTo(Rotation,System.Single)">
            <summary>
            AGH! This doesn't work! Either the Rotation.Difference or .Angles() is fucked!
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.MoveTo(Angles,System.Single)">
            <summary>
            Angles. Blah.
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.MoveFinished">
            <summary>
            Called when your move is finished
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.MoveBlocked(Sandbox.Entity)">
            <summary>
            Called when your move is blocked
            </summary>
        </member>
        <member name="P:Sandbox.ModelEntity.PhysicsEnabled">
            <summary>
            Enable or disable physics motion
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.GetBonePhysicsBody(System.Int32)">
            <summary>
            Get the physics body attached to this bone
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.GetBone(Sandbox.PhysicsBody)">
            <summary>
            Get the bone that this physics body is attached to
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.PhysicsClear">
            <summary>
            Destroy any physics objects
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.GetHitboxBone(System.Int32)">
            <summary>
            Return which bone is this hitbox attached to.
            </summary>
        </member>
        <member name="M:Sandbox.ModelEntity.GetHitboxGroup(System.Int32)">
            <summary>
            Return group id for this hitbox.
            </summary>
        </member>
        <member name="P:Sandbox.ModelEntity.HitboxSet">
            <summary>
            The currently active hitbox set.
            </summary>
        </member>
        <member name="F:Sandbox.GlowStates.Off">
            <summary>Doesn't show any glow.</summary>
        </member>
        <member name="F:Sandbox.GlowStates.Use">
            <summary>Glow appears when object is useable.</summary>
        </member>
        <member name="F:Sandbox.GlowStates.LookAt">
            <summary>Glow appears when you look at object.</summary>
        </member>
        <member name="F:Sandbox.GlowStates.On">
            <summary>Glow is always enabled when active.</summary>
        </member>
        <member name="F:Sandbox.MoveType.Physics">
            <summary>
            Use physics simulation
            </summary>
        </member>
        <member name="F:Sandbox.MoveType.Push">
            <summary>
            no clip to world, push and crush
            </summary>
        </member>
        <member name="T:Sandbox.BaseNetworkable">
            <summary>
            A network capable object
            </summary>
        </member>
        <member name="P:Sandbox.BaseNetworkable.NetworkIdent">
            <summary>
            Should return an ID of this networkable that is common across the network
            </summary>
        </member>
        <member name="M:Sandbox.BaseNetworkable.WriteNetworkData">
            <summary>
            Serialize this class to the network. You shouldn't need to call this manually unless you're 
            implementing INetworkSerializer and want to force a write. In other situations we can detect
            when things change and update them manually.
            </summary>
        </member>
        <member name="M:Sandbox.BaseNetworkable.RpcWriteIdent(Sandbox.NetWrite)">
            <summary>
            Writes the RpcClient identity to a network message. This works
            by calling the parent functions first so that they'll be read back
            in the right order.
            </summary>
        </member>
        <member name="M:Sandbox.BaseNetworkable.OnCallRemoteProcedure(System.Int32,Sandbox.NetRead)">
            <summary>
             Generated at compile-time: calls remote procedure implementations
            </summary>
        </member>
        <member name="M:Sandbox.BaseNetworkable.ReceiveMessageFromServer(Sandbox.NetRead)">
            <summary>
            Called from engine clientside when an entity message has been recieved
            </summary>
        </member>
        <member name="T:Sandbox.OrthoLightEntity">
            <summary>
            A directional, orthographic light entity.
            </summary>
        </member>
        <member name="P:Sandbox.OrthoLightEntity.Range">
            <summary>
            Distance range for light. 0=infinite
            </summary>
        </member>
        <member name="P:Sandbox.OrthoLightEntity.FadeDistanceMin">
            <summary>
            Distance at which the light starts to fade. (less than 0 = use fademaxdist)
            </summary>
        </member>
        <member name="P:Sandbox.OrthoLightEntity.FadeDistanceMax">
            <summary>
            Maximum distance at which the light is visible. (0 = don't fade out)
            </summary>
        </member>
        <member name="P:Sandbox.OrthoLightEntity.FogStength">
            <summary>
            Overrides how much the light affects the fog. (if enabled)
            </summary>
        </member>
        <member name="T:Sandbox.Bot">
            <summary>
            Create a bot. When you create one of these, a fake client will join the server and its input and behavior
            can be controlled by overriding the BuildInput method serverside. Bots otherwise act like regular clients
            and also have their own pawn.
            </summary>
        </member>
        <member name="M:Sandbox.Bot.SetDefaultNames(System.Collections.Generic.List{System.String})">
            <summary>
            Set a list of default bot names. Unless a bot is given a specific name, a name
            will be chosen from this list until they have all been used. If all names have been
            used already, a random name will be chosen from the list
            </summary>
        </member>
        <member name="P:Sandbox.Bot.Client">
            <summary>
            The fake client that this bot represents
            </summary>
        </member>
        <member name="M:Sandbox.Bot.BuildInput(Sandbox.InputBuilder)">
            <summary>
            Called serverside each frame to build the bot's input data. You can use this to set what
            buttons a bot is pressing, or where they should be looking, for example
            </summary>
        </member>
        <member name="M:Sandbox.Bot.Tick">
            <summary>
            Called serverside for each tick that the bot exists in the server
            </summary>
        </member>
        <member name="P:Sandbox.Client.PlayerId">
            <summary>
            The Id of this client. This is generally their SteamId.
            </summary>
        </member>
        <member name="P:Sandbox.Client.Name">
            <summary>
            The Steam name of this client.
            </summary>
        </member>
        <member name="P:Sandbox.Client.NetworkIdent">
            <summary>
            The entity ID of this client. These will be reused as players join and leave.
            </summary>
        </member>
        <member name="P:Sandbox.Client.SessionId">
            <summary>
            User ID of this client. These IDs will never be reused, even for the same player after rejoin.
            </summary>
        </member>
        <member name="P:Sandbox.Client.VoiceLevel">
            <summary>
            Last voice level heard
            </summary>
        </member>
        <member name="P:Sandbox.Client.TimeSinceLastVoice">
            <summary>
            Time since client last spoke on voice chat
            </summary>
        </member>
        <member name="M:Sandbox.Client.GetClientData(System.String,System.String)">
            <summary>
            Gets the convar value from a ClientData convar
            </summary>
        </member>
        <member name="M:Sandbox.Client.GetClientData``1(System.String,``0)">
            <summary>
            Gets the convar value from a ClientData convar
            </summary>
        </member>
        <member name="M:Sandbox.Client.Kick">
            <summary>
            Kick this client from the server.
            </summary>
        </member>
        <member name="P:Sandbox.Client.IsListenServerHost">
            <summary>
            Returns true if this client is the listen server host
            </summary>
        </member>
        <member name="P:Sandbox.Client.Components">
            <summary>
            Set/Get components for this client
            </summary>
        </member>
        <member name="P:Sandbox.Client.Ping">
            <summary>
            The time it takes for a network message to get to this client
            </summary>
        </member>
        <member name="P:Sandbox.Client.PacketLoss">
            <summary>
            This client's packet loss as a percentage (0-100)
            </summary>
        </member>
        <member name="P:Sandbox.ClientEntity.IsLocalPlayer">
            <summary>
            Returns true if this is the local player. This will
            only return true on the client for the player that is
            being controlled. It won't ever return true serverside.
            </summary>
        </member>
        <member name="P:Sandbox.ClientEntity.PlayerId">
            <summary>
            This player's SteamId
            </summary>
        </member>
        <member name="M:Sandbox.ClientEntity.SendCommandToClient(System.String)">
            <summary>
            Send a console command to this client to be run. Use ConsoleSystem.Build to safely build
            a console command.
            </summary>
        </member>
        <member name="M:Sandbox.ClientEntity.SetGameResult(Sandbox.GameplayResult,System.Single)">
            <summary>
            Convenience function, calls GameServices.RecordScore
            </summary>
        </member>
        <member name="M:Sandbox.ClientEntity.PlayerSetupVisibility(System.Int32,System.IntPtr)">
            <summary>
            Called by the server to determine what the player can see, from a network pov
            Add points here that the player should see.
            </summary>
        </member>
        <member name="P:Sandbox.ClientEntity.Pvs">
            <summary>
            Potentially Visible Set. Use this to add new areas to the player's PVS. This is useful if you're
            spectating another entity and want to be able to see what they see etc.
            </summary>
        </member>
        <member name="M:Sandbox.PvsConfig.Add(Sandbox.Entity)">
            <summary>
            Add an entity tp the player's PVS. The player will be able to see everything that this entity can see.
            </summary>
        </member>
        <member name="M:Sandbox.PvsConfig.Remove(Sandbox.Entity)">
            <summary>
            Remove entity from this player's PVS
            </summary>
        </member>
        <member name="M:Sandbox.PvsConfig.Clear">
            <summary>
            Remove all specialization
            </summary>
        </member>
        <member name="M:Sandbox.PvsConfig.Clean">
            <summary>
            Remove all entries that aren't value
            </summary>
        </member>
        <member name="M:Sandbox.Input.GetKeyWithBinding(System.String)">
            <summary>
            Returns the name of a key that is bound to this value
            </summary>
        </member>
        <member name="P:Sandbox.Input.Forward">
            <summary>
            A float in range of -1 to 0 to 1 that represents how much the user wants to move forwards (1) or backwards (-1)
            </summary>
        </member>
        <member name="P:Sandbox.Input.Left">
            <summary>
            A float in range of -1 to 0 to 1 that represents how much the user wants to move left (1) or right (-1)
            </summary>
        </member>
        <member name="P:Sandbox.Input.Up">
            <summary>
            A float in range of -1 to 0 to 1 that represents how much the user wants to move up (1) or down (-1)
            </summary>
        </member>
        <member name="P:Sandbox.Input.Position">
            <summary>
            The location of the camera on the client when this command was issued
            </summary>
        </member>
        <member name="M:Sandbox.Input.Down(Sandbox.InputButton)">
            <summary>
            Button is pressed down
            </summary>
        </member>
        <member name="M:Sandbox.Input.Pressed(Sandbox.InputButton)">
            <summary>
            Button wasn't pressed but now is it
            </summary>
        </member>
        <member name="M:Sandbox.Input.Released(Sandbox.InputButton)">
            <summary>
            Button was pressed but now it isn't
            </summary>
        </member>
        <member name="M:Sandbox.Input.UpdateFrom(Sandbox.Client,NativeEngine.CUserCmd@)">
            <summary>
            Called every tick
            </summary>
        </member>
        <member name="M:Sandbox.Input.UpdateFromInput(NativeEngine.InputData)">
            <summary>
            Called each frame
            </summary>
        </member>
        <member name="M:Sandbox.Input.UpdateFromUserCmd(NativeEngine.CUserCmd@)">
            <summary>
            Called each frame
            </summary>
        </member>
        <member name="M:Sandbox.Input.Clear">
            <summary>
            Todo clear the lot
            </summary>
        </member>
        <member name="M:Sandbox.Input.UpdateForClient(Sandbox.Client)">
            <summary>
            We want Input.VR.IsActive to return the correct values on client join
            </summary>
        </member>
        <member name="P:Sandbox.Input.VrHand.Transform">
            <summary>
            Transform of this hand
            </summary>
        </member>
        <member name="P:Sandbox.Input.VrHand.Velocity">
            <summary>
            Velocity of this hand
            </summary>
        </member>
        <member name="P:Sandbox.Input.VrHand.AngularVelocity">
            <summary>
            Velocity of this hand
            </summary>
        </member>
        <member name="P:Sandbox.Input.VrInput.IsVive">
            <summary>
            Returns true if this is a vive
            </summary>
        </member>
        <member name="P:Sandbox.Input.VrInput.IsRift">
            <summary>
            Returns true if this is a rift or a touch
            </summary>
        </member>
        <member name="P:Sandbox.Input.VrInput.IsKnuckles">
            <summary>
            Returns true if this is an index
            </summary>
        </member>
        <member name="P:Sandbox.Input.VrInput.Type">
            <summary>
            Returns the headset type - like "vive", "touch", "rift". Returns empty string if unknown.
            </summary>
        </member>
        <member name="T:Sandbox.PointLightEntity">
            <summary>
            An omnidirectional light entity.
            </summary>
        </member>
        <member name="P:Sandbox.PointLightEntity.Range">
            <summary>
            Distance range for light. 0=infinite
            </summary>
        </member>
        <member name="P:Sandbox.PointLightEntity.FadeDistanceMin">
            <summary>
            Distance at which the light starts to fade. (less than 0 = use fademaxdist)
            </summary>
        </member>
        <member name="P:Sandbox.PointLightEntity.FadeDistanceMax">
            <summary>
            Maximum distance at which the light is visible. (0 = don't fade out)
            </summary>
        </member>
        <member name="P:Sandbox.PointLightEntity.FogStength">
            <summary>
            Overrides how much the light affects the fog. (if enabled)
            </summary>
        </member>
        <member name="M:Sandbox.RenderEntity.UpdateSceneObject(Sandbox.SceneObject)">
            <summary>
            Keep the scene object updated. By default this moves the transform to match this entity's transform
            and updates the bounds to the new position.
            </summary>
        </member>
        <member name="M:Sandbox.RenderEntity.DoRender(Sandbox.SceneObject)">
            <summary>
            Render this entity. Here's some warnings:
            1. This is called in a thread. Don't create/delete/move entities in this loop
            2. This can be called multiple times per frame for different scene layers. For example, once to
            	draw the shadow caster, once to draw the opaque object, once to draw the transparent object.
            	Obviously which of these get called depends on your object setup. Check Render.Layer to
            	determine which layer is being rendered.
            </summary>
        </member>
        <member name="T:Sandbox.SpotLightEntity">
            <summary>
            A directional spot light entity.
            </summary>
        </member>
        <member name="P:Sandbox.SpotLightEntity.Range">
            <summary>
            Distance range for light. 0=infinite
            </summary>
        </member>
        <member name="P:Sandbox.SpotLightEntity.Falloff">
            <summary>
            Angular falloff exponent. Does not work with light cookies. Does not work with dynamic lighting.
            </summary>
        </member>
        <member name="P:Sandbox.SpotLightEntity.InnerConeAngle">
            <summary>
            Inner cone angle. No angular falloff within this cone.
            </summary>
        </member>
        <member name="P:Sandbox.SpotLightEntity.OuterConeAngle">
            <summary>
            Outer cone angle.
            </summary>
        </member>
        <member name="P:Sandbox.SpotLightEntity.FadeDistanceMin">
            <summary>
            Distance at which the light starts to fade. (less than 0 = use fademaxdist)
            </summary>
        </member>
        <member name="P:Sandbox.SpotLightEntity.FadeDistanceMax">
            <summary>
            Maximum distance at which the light is visible. (0 = don't fade out)
            </summary>
        </member>
        <member name="P:Sandbox.SpotLightEntity.ShadowFadeDistanceMin">
            <summary>
            Distance at which the shadow starts to fade. (less than 0 = use 'Shadow End Fade Dist')
            </summary>
        </member>
        <member name="P:Sandbox.SpotLightEntity.ShadowFadeDistanceMax">
            <summary>
            Maximum distance at which the shadow is visible. (0 = don't fade out)
            </summary>
        </member>
        <member name="P:Sandbox.SpotLightEntity.FogStength">
            <summary>
            Overrides how much the light affects the fog. (if enabled)
            </summary>
        </member>
        <member name="T:Sandbox.WorldEntity">
            <summary>
            The world entity.
            </summary>
        </member>
        <member name="T:Sandbox.FileSystem">
            <summary>
            A filesystem that can be accessed by the game
            </summary>
        </member>
        <member name="T:Sandbox.GameBase">
            <summary>
            This is the engine connection to the game entity. 
            You should derive your game from Sandbox.Game rather than this.
            </summary>
        </member>
        <member name="M:Sandbox.GameBase.Shutdown">
            <summary>
            Called when the server is going away
            </summary>
        </member>
        <member name="M:Sandbox.GameBase.ClientJoined(Sandbox.Client)">
            <summary>
            Client has joined the server. Create their puppets.
            </summary>
        </member>
        <member name="M:Sandbox.GameBase.ClientDisconnect(Sandbox.Client,Sandbox.NetworkDisconnectionReason)">
            <summary>
            Client has disconnected from the server. Remove their entities etc.
            </summary>
        </member>
        <member name="M:Sandbox.GameBase.CanHearPlayerVoice(Sandbox.Client,Sandbox.Client)">
            <summary>
            Can we hear the player's voice. If not we won't send the data to this client.
            </summary>
        </member>
        <member name="M:Sandbox.GameBase.BuildCamera(Sandbox.CameraSetup)">
            <summary>
            Update the camera setup
            </summary>
        </member>
        <member name="M:Sandbox.GameBase.OnVoicePlayed(System.Int64,System.Single)">
            <summary>
            Someone is speaking via voice chat. This might be someone in your game, 
            or in your party, or in your lobby.
            </summary>
        </member>
        <member name="P:Sandbox.GameLobby.Id">
            <summary>
            This is the server's LobbyId.
            </summary>
        </member>
        <member name="M:Sandbox.GameLobby.StartLobby(System.UInt64)">
            <summary>
            Called from the menu when someone is in a lobby and they want to turn it into a game.
            </summary>
        </member>
        <member name="M:Sandbox.GameLobby.FindOrCreateAsync(System.String,System.String)">
            <summary>
            We're stating a new game. Make sure we have a lobby!
            </summary>
        </member>
        <member name="M:Sandbox.GameLobby.JoinServerLobby(System.UInt64)">
            <summary>
            Called from client when joining a server to join the game lobby too.
            </summary>
        </member>
        <member name="M:Sandbox.GameLobby.Leave">
            <summary>
            Leave the game lobby, called on game end, disconnect
            </summary>
        </member>
        <member name="M:Sandbox.GameLoop.PreOnActivate">
            <summary>
            Server: Right before map entity spawn
            </summary>
        </member>
        <member name="M:Sandbox.GameLoop.PostOnActivate">
            <summary>
            Server: Right after map entity spawn
            </summary>
        </member>
        <member name="M:Sandbox.GameLoop.LoopShutdown">
            <summary>
            The last thing that is ever called.
            This is right at the end after everything has been destroyed.
            </summary>
        </member>
        <member name="M:Sandbox.GameLoop.DoShutdown">
            <summary>
            Called to clear the state. Because of spagetti code this is probably called in 4
            different places when disconnecting from a server.
            </summary>
        </member>
        <member name="M:Sandbox.GameLoop.NotifyDisconnect(System.Int32,System.String)">
            <summary>
            Called when the local client was disconnected from the current server for any reason.
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.Attacker">
            <summary>
            The player or NPC or exploding barrel (etc)1 that is attacking
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.Weapon">
            <summary>
            The weapon that the attacker is using
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.Position">
            <summary>
            The position the damage is being inflicted (the bullet entry point)
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.Force">
            <summary>
            The force of the damage - for moving physics etc. This would be the tradjectory
            of the bullet multiplied by the speed and mass.
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.Damage">
            <summary>
            The actual amount of damage this attack causes
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.Flags">
            <summary>
            Damage flags, extra infomation about this attack
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.Body">
            <summary>
            The physics body that was hit
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.HitboxIndex">
            <summary>
            The hitbox index
            </summary>
        </member>
        <member name="P:Sandbox.DamageInfo.BoneIndex">
            <summary>
            The bone index that the hitbox was attached to
            </summary>
        </member>
        <member name="M:Sandbox.DamageInfo.FromBullet(Vector3,Vector3,System.Single)">
            <summary>
            Creates a new DamageInfo with the DamageFlag Bullet
            </summary>
        </member>
        <member name="M:Sandbox.DamageInfo.Generic(System.Single)">
            <summary>
            Creates a new DamageInfo with the DamageFlag Generic
            </summary>
        </member>
        <member name="M:Sandbox.DamageInfo.Explosion(Vector3,Vector3,System.Single)">
            <summary>
            Creates a new DamageInfo with the DamageFlag Blast
            </summary>
        </member>
        <member name="M:Sandbox.DamageInfo.WithAttacker(Sandbox.Entity,Sandbox.Entity)">
            <summary>
            Set the attacker
            </summary>
        </member>
        <member name="M:Sandbox.DamageInfo.WithWeapon(Sandbox.Entity)">
            <summary>
            Set the attacker
            </summary>
        </member>
        <member name="M:Sandbox.DamageInfo.WithFlag(Sandbox.DamageFlags)">
            <summary>
            Add flag(s)
            </summary>
        </member>
        <member name="M:Sandbox.DamageInfo.WithHitBody(Sandbox.PhysicsBody)">
            <summary>
            Sets the hit physics body
            </summary>
        </member>
        <member name="M:Sandbox.DamageInfo.WithHitbox(System.Int32)">
            <summary>
            Sets the hitbox index
            </summary>
        </member>
        <member name="M:Sandbox.DamageInfo.WithBone(System.Int32)">
            <summary>
            Sets the hitbox index
            </summary>
        </member>
        <member name="M:Sandbox.DamageInfo.WithPosition(Vector3)">
            <summary>
            Sets the position
            </summary>
        </member>
        <member name="M:Sandbox.DamageInfo.WithForce(Vector3)">
            <summary>
            Sets the force
            </summary>
        </member>
        <member name="M:Sandbox.DamageInfo.UsingTraceResult(Sandbox.TraceResult)">
            <summary>
            Fills in the PhysicsBody and Hitbox from the trace result
            </summary>
        </member>
        <member name="F:Sandbox.LifeState.Alive">
            <summary>
            Alive as normal
            </summary>
        </member>
        <member name="F:Sandbox.LifeState.Dying">
            <summary>
            Playing a death animation
            </summary>
        </member>
        <member name="F:Sandbox.LifeState.Dead">
            <summary>
            Dead, lying still
            </summary>
        </member>
        <member name="F:Sandbox.LifeState.Respawnable">
            <summary>
            Can respawn, usually waiting for some client action to respawn
            </summary>
        </member>
        <member name="F:Sandbox.LifeState.Respawning">
            <summary>
            Is in the process of respawning
            </summary>
        </member>
        <member name="M:Sandbox.InputBuilder.Down(Sandbox.InputButton)">
            <summary>
            Button is pressed down
            </summary>
        </member>
        <member name="M:Sandbox.InputBuilder.Pressed(Sandbox.InputButton)">
            <summary>
            Button wasn't pressed but now is it
            </summary>
        </member>
        <member name="M:Sandbox.InputBuilder.Released(Sandbox.InputButton)">
            <summary>
            Button was pressed but now it isn't
            </summary>
        </member>
        <member name="M:Sandbox.InputBuilder.ClearButton(Sandbox.InputButton)">
            <summary>
            Remove this button, so it's no longer being pressed
            </summary>
        </member>
        <member name="M:Sandbox.InputBuilder.SetButton(Sandbox.InputButton,System.Boolean)">
            <summary>
            Set button as pressed down
            </summary>
        </member>
        <member name="M:Sandbox.InputBuilder.SuppressButton(Sandbox.InputButton)">
            <summary>
            Suppress a button, it won't show as down again until it's pressed again
            </summary>
        </member>
        <member name="M:Sandbox.InputBuilder.Process(NativeEngine.InputData@)">
            <summary>
            Called multiple times between ticks
            </summary>
        </member>
        <member name="P:Sandbox.VR.Enabled">
            <summary>
            Returns true if VR is active
            </summary>
        </member>
        <member name="P:Sandbox.VR.Scale">
            <summary>
            Get or set the player's scale in the world. If you set it to 2 the player will be twice as big.
            </summary>
        </member>
        <member name="P:Sandbox.VR.Anchor">
            <summary>
            The anchor transform. This is usually where the VR player is standing. Your pawn's position
            is the default place for this.
            </summary>
        </member>
        <member name="P:Sandbox.VR.DashboardIsOpen">
            <summary>
            Returns true if the SteamVR dashboard is visible
            </summary>
        </member>
        <member name="P:Sandbox.VR.ControllersAreDrawing">
            <summary>
            Returns true if SteamVR is drawing the controllers
            </summary>
        </member>
        <member name="P:Sandbox.VR.IsLeftHandDominant">
            <summary>
            Returns true if the left hand is dominant
            </summary>
        </member>
        <member name="M:Sandbox.VR.GetLeftControllerModel">
            <summary>
            Returns an appropriate model for the left controller
            </summary>
        </member>
        <member name="M:Sandbox.VR.GetRightControllerModel">
            <summary>
            Returns an appropriate model for the right controller
            </summary>
        </member>
        <member name="P:Sandbox.Light.LightColor">
            <summary>
            Color and brightness of the light
            </summary>
        </member>
        <member name="P:Sandbox.Light.Falloff">
            <summary>
            Attenuation of how much brightness the light loses the more it travels
            </summary>
        </member>
        <member name="P:Sandbox.Light.Radius">
            <summary>
            Radius of the light in units
            </summary>
        </member>
        <member name="P:Sandbox.SpotLight.SpotCone">
            <summary>
            Sets how much the spot light would spread, with inner and outer cone angles in degrees
            </summary>
        </member>
        <member name="M:Sandbox.SunLight.ConnectOrCreateThisNative">
            <summary>
            Fetch the current sunlight from the world if such exists, if not, create a new sunlight
            </summary>
        </member>
        <member name="P:Sandbox.Friend.IsMe">
            <summary>
            Returns true if this friend is the local user
            </summary>
        </member>
        <member name="P:Sandbox.Friend.Id">
            <summary>
            The friend's Steam Id
            </summary>
        </member>
        <member name="P:Sandbox.Friend.Name">
            <summary>
            The friend's name
            </summary>
        </member>
        <member name="P:Sandbox.Friend.IsOnline">
            <summary>
            Returns true if your friend is online
            </summary>
        </member>
        <member name="P:Sandbox.Friend.IsFriend">
            <summary>
            Returns true if this user is your friend
            </summary>
        </member>
        <member name="P:Sandbox.Friend.IsAway">
            <summary>
            Returns true if your friend is away
            </summary>
        </member>
        <member name="M:Sandbox.Friend.GetRichPresence(System.String)">
            <summary>
            Returns a string that was possibly set by rich presence
            </summary>
        </member>
        <member name="P:Sandbox.Friend.IsPlayingThisGame">
            <summary>
            Returns true if they're playing this game
            </summary>
        </member>
        <member name="P:Sandbox.Friend.IsPlayingAGame">
            <summary>
            Returns true if they're playing any game
            </summary>
        </member>
        <member name="M:Sandbox.Friend.GetAll">
            <summary>
            Get all friends. 
            </summary>
            <returns></returns>
        </member>
        <member name="P:Sandbox.Lobby.OwnerId">
            <summary>
            The owner of this lobby. Unlike .Owner this is accessible without join
            </summary>
        </member>
        <member name="P:Sandbox.Lobby.Title">
            <summary>
            The title of this lobby. Think of this as the server name.
            </summary>
        </member>
        <member name="P:Sandbox.Lobby.Game">
            <summary>
            The game ident of this lobby. 
            </summary>
        </member>
        <member name="P:Sandbox.Lobby.State">
            <summary>
            The current state of this lobby, ie "staging", "active"
            </summary>
        </member>
        <member name="P:Sandbox.Lobby.Map">
            <summary>
            The current map for this lobby
            </summary>
        </member>
        <member name="P:Sandbox.Lobby.Data">
            <summary>
            Allows iteration of all data fields
            </summary>
        </member>
        <member name="M:Sandbox.Lobby.SendChat(System.String)">
            <summary>
            Send chat message to the lobby
            </summary>
        </member>
        <member name="P:Sandbox.Lobby.MaxMembers">
            <summary>
            Maximum number of people allowed in the lobby
            </summary>
        </member>
        <member name="P:Sandbox.Lobby.MemberCount">
            <summary>
            Number of people in the lobby
            </summary>
        </member>
        <member name="P:Sandbox.Lobby.Owner">
            <summary>
            Get the owner of the lobby. Only the owner of the lobby can change the owner.
            </summary>
        </member>
        <member name="T:Sandbox.Lobby.AccessMode">
            <summary>
            TODO: These names make no sense, Valve fucked us
            </summary>
        </member>
        <member name="F:Sandbox.Lobby.OnPartyInvite">
            <summary>
            Party invite has been created
            </summary>
        </member>
        <member name="P:Sandbox.Lobby.Active">
            <summary>
            A of lobbies we're active in
            </summary>
        </member>
        <member name="F:Sandbox.NavAreaAttribute.Crouch">
            <summary>
            Must crouch to use this node/area
            </summary>
        </member>
        <member name="F:Sandbox.NavAreaAttribute.Jump">
            <summary>
            Must jump to traverse this area (only used during generation)
            </summary>
        </member>
        <member name="F:Sandbox.NavAreaAttribute.Precise">
            <summary>
            Do not adjust for obstacles, just move along area
            </summary>
        </member>
        <member name="F:Sandbox.NavAreaAttribute.NoJump">
            <summary>
            Inhibit discontinuity jumping
            </summary>
        </member>
        <member name="F:Sandbox.NavAreaAttribute.Avoid">
            <summary>
            Avoid this area unless alternatives are too dangerous
            </summary>
        </member>
        <member name="F:Sandbox.NavAreaAttribute.Stairs">
            <summary>
            This area represents stairs, do not attempt to climb or jump them - just walk up
            </summary>
        </member>
        <member name="F:Sandbox.NavAreaAttribute.NoMerge">
            <summary>
            Don't merge this area with adjacent areas
            </summary>
        </member>
        <member name="F:Sandbox.NavAreaAttribute.ObstacleTop">
            <summary>
            This nav area is the climb point on the tip of an obstacle
            </summary>
        </member>
        <member name="F:Sandbox.NavAreaAttribute.Cliff">
            <summary>
            This nav area is adjacent to a drop of at least CliffHeight
            </summary>
        </member>
        <member name="M:Sandbox.NavMesh.GetClosestPoint(Vector3)">
            <summary>
            Returns the closest point on the navmesh. Or null if not found.
            </summary>
        </member>
        <member name="M:Sandbox.NavMesh.GetPointWithinRadius(Vector3,System.Single,System.Single)">
            <summary>
            Returns the closest point on the navmesh. Or null if not found.
            </summary>
        </member>
        <member name="M:Sandbox.NavMesh.BuildPathEx(Vector3,Vector3,System.Collections.Generic.List{Sandbox.NavNode},System.Single,System.Single)">
            <summary>
            Return a path built between a start and an end point. This is different to BuildPath as it returns more detailed information
            on each node
            </summary>
        </member>
        <member name="M:Sandbox.NavMesh.BuildPathEx(Vector3,Vector3,System.Single,System.Single)">
            <summary>
            Return a path built between a start and an end point. This is different to BuildPath as it returns more detailed information
            on each node
            </summary>
        </member>
        <member name="M:Sandbox.NavMesh.GetAreaAttribute(Vector3)">
            <summary>
            Finds the closest nav area to a point and returns all the attributes associated with it as a bit flag.
            </summary>
        </member>
        <member name="F:Sandbox.NavNode.SegmentType">
            <summary>
            How to traverse this segment of the path
            </summary>
        </member>
        <member name="F:Sandbox.NavNode.EnterType">
            <summary>
            How to exit the previous area to get to this one
            </summary>
        </member>
        <member name="F:Sandbox.NavNode.AreaFlags">
            <summary>
            The current areas navigation attributes, are these stairs? Do you need to crouch here? etc. This is a bit flag!
            </summary>
        </member>
        <member name="F:Sandbox.NavNode.PreviousAreaFlags">
            <summary>
            The previous areas navigation attributes, are these stairs? Do you need to crouch here? etc. This is a bit flag!
            </summary>
        </member>
        <member name="F:Sandbox.NavNode.Position">
            <summary>
            Our movement goal position at this point in the path
            </summary>
        </member>
        <member name="F:Sandbox.NavNode.Direction">
            <summary>
            The forward direction of the path segment
            </summary>
        </member>
        <member name="F:Sandbox.NavNode.Length">
            <summary>
            The current length of the segment
            </summary>
        </member>
        <member name="F:Sandbox.NavNode.DistanceFromStart">
            <summary>
            How far the segment is from the start
            </summary>
        </member>
        <member name="F:Sandbox.NavNode.Curvature">
            <summary>
            How much the path "curves" at this point in the XY plane (0 = none, 1 = 180 degree double-back)
            </summary>
        </member>
        <member name="T:Sandbox.NetworkTable">
            <summary>
            Each entity has a network table
            </summary>
        </member>
        <member name="M:Sandbox.NetworkTable.CanWrite(System.Boolean)">
            <summary>
            Can write under specific conditions
            </summary>
        </member>
        <member name="M:Sandbox.NetworkTable.Clear">
            <summary>
            Erase everything from the network tables
            </summary>
        </member>
        <member name="M:Sandbox.NetworkTable.AddVariable(Sandbox.Internal.Var,System.Nullable{System.Int32})">
            <summary>
            Add a variable to this entity
            </summary>
        </member>
        <member name="M:Sandbox.NetworkTable.GetAt(System.Int32)">
            <summary>
            Try to get variable in slot
            </summary>
        </member>
        <member name="M:Sandbox.NetworkTable.Release(Sandbox.Internal.Var)">
            <summary>
             Remove this variable from the data table, freeing up the slot
            </summary>
        </member>
        <member name="T:Sandbox.NetworkAssetList">
            <summary>
            Creates and maintains a list of available assets that the client can download
            Along with their CRCs - which we can use to assure we're using the same shit
            </summary>
        </member>
        <member name="M:Sandbox.NetworkAssetList.Initialize">
            <summary>
            Populates with all files
            </summary>
        </member>
        <member name="M:Sandbox.NetworkAssetList.IgnoredFile(System.String)">
            <summary>
            Opportunity to filter out files we don't want to send to the client
            </summary>
        </member>
        <member name="P:Sandbox.ServerInfo.MountedAddons">
            <summary>
            Addons that the user should have installed and mounted
            </summary>
        </member>
        <member name="P:Sandbox.NetRead.Remaining">
            <summary>
            The amount of data (in bytes) remaining to be read
            </summary>
        </member>
        <member name="M:Sandbox.NetRead.IsSupported(System.Type)">
            <summary>
            Get whether or not a type can be read by NetRead.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.NetRead.IsSupported``1(System.Span{``0})">
            <summary>
            Get whether or not a value can be read by NetRead. This is a little
            trick because `GetType()` does not work with Span.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.NetRead.IsSupported(System.Object)">
            <summary>
            Get whether or not a value can be read by NetRead.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.NetRead.ReadUnmanagedArray``1(``0[])">
            <summary>
            A dedicated method for arrays of unmanaged types that is faster to allow processing
            of large arrays
            </summary>
        </member>
        <member name="M:Sandbox.NetRead.TryRead``1">
            <summary>
            Like read, but will return default if not enough size left
            </summary>
        </member>
        <member name="M:Sandbox.Networking.OnNetMessage(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            The entrance point from the engine when a managed network message is recvd
            </summary>
        </member>
        <member name="M:Sandbox.NetWrite.WriteUnmanagedArray``1(``0[])">
            <summary>
            A dedicated method for writing an array of unmanaged types
            </summary>
        </member>
        <member name="M:Sandbox.Prediction.Tick">
            <summary>
            At this point if we're scoping right, prediction should always be enabled.
            If it isn't then someone fucked up - lets not let that problem persist forever.
            </summary>
        </member>
        <member name="M:Sandbox.Prediction.Read(Sandbox.NetRead@)">
            <summary>
            On recieving a network RPC we read who was being simulated when 
            the RPC was sent. If that was us then we set SupressTest to true.
            </summary>
        </member>
        <member name="T:Sandbox.RpcHistory">
            <summary>
            On the client prediction remembers every RPC called during a tick.
            When a RPC comes from the server we compare it to our history and if
            it doesn't exist then we call it.
            </summary>
        </member>
        <member name="T:Sandbox.To">
            <summary>
            A wrapper to define which clients to send network things to. This
            aims to make code more readable by having the target argument in generated
            functions be more obvious and visible.
            </summary>
        </member>
        <member name="M:Sandbox.To.Single(Sandbox.Entity)">
            <summary>
            Send to a single client (the client owner of this pawn)
            </summary>
        </member>
        <member name="M:Sandbox.To.Single(Sandbox.Client)">
            <summary>
            Send to a single client
            </summary>
        </member>
        <member name="M:Sandbox.To.Multiple(System.Collections.Generic.IEnumerable{Sandbox.Client})">
            <summary>
            Send to multiple clients
            </summary>
        </member>
        <member name="P:Sandbox.To.Everyone">
            <summary>
            The same as To.Multiple( Client.All )
            </summary>
        </member>
        <member name="M:Sandbox.Precache.Add(System.String)">
            <summary>
            Add a resource that the client should load. This is called 
            automatically when doing things such as setting a model and for
            the most part you should never have to call this.
            </summary>
        </member>
        <member name="M:Sandbox.Precache.OnStringAddedOrChanged(System.Int32)">
            <summary>
            Player info has changed
            </summary>
        </member>
        <member name="M:Sandbox.StringPool.OnStringAddedOrChanged(System.Int32)">
            <summary>
            String table changed
            </summary>
        </member>
        <member name="M:Sandbox.StringTables.Init">
            <summary>
            On server this gets called once
            On client this can get called multiple times
            </summary>
        </member>
        <member name="P:Sandbox.StringTable.Name">
            <summary>
            The name of this string table
            </summary>
        </member>
        <member name="M:Sandbox.StringTable.Count">
            <summary>
            Returns the number of strings in this table
            </summary>
        </member>
        <member name="F:Sandbox.StringTable.OnStringAddedOrChanged">
            <summary>
            Called clientside when a string is added or changed
            </summary>
        </member>
        <member name="F:Sandbox.CollisionGroup.Always">
            <summary>
            This will *ALWAYS* collide
            This group does not generate contacts or interact with any other groups by default
            </summary>
        </member>
        <member name="F:Sandbox.CollisionGroup.Never">
            <summary>
            Never collide with anything
            </summary>
        </member>
        <member name="F:Sandbox.CollisionGroup.Trigger">
            <summary>
            Trigger layer, never collides with anything, only triggers/interacts
            </summary>
        </member>
        <member name="F:Sandbox.CollisionGroup.ConditionallySolid">
            <summary>
            Conditionally solid means that the collision response will be zero or as defined in the table when there are matching interactions
            </summary>
        </member>
        <member name="F:Sandbox.CollisionGroup.Default">
            <summary>
            standard dynamic rigid object, finite mass
            </summary>
        </member>
        <member name="F:Sandbox.CollisionGroup.Debris">
            <summary>
            Collides with nothing but world and static stuff
            </summary>
        </member>
        <member name="F:Sandbox.CollisionGroup.DebrisInteractive">
            <summary>
            Collides with everything except other interactive debris or debris
            </summary>
        </member>
        <member name="F:Sandbox.CollisionGroup.Interactive">
            <summary>
            Collides with everything except interactive debris or debris
            </summary>
        </member>
        <member name="F:Sandbox.CollisionLayer.Player">
            <summary>
            Player hull (movement and trace attacks)
            </summary>
        </member>
        <member name="F:Sandbox.CollisionLayer.Debris">
            <summary>
            Ragdolls etc
            </summary>
        </member>
        <member name="M:Sandbox.Joints.ConicalJointBuilder.Create">
            <summary>
            Finish creation of joint
            </summary>
        </member>
        <member name="M:Sandbox.Joints.GenericJointBuilder.Create">
            <summary>
            Finish creation of joint
            </summary>
        </member>
        <member name="M:Sandbox.Joints.PrismaticJointBuilder.Create">
            <summary>
            Finish creation of joint
            </summary>
        </member>
        <member name="M:Sandbox.Joints.RevoluteJointBuilder.WithLimitEnabled(System.Single,System.Single)">
            <summary>
            Enables hinge limit
            </summary>
            <param name="minAngle">Minimum hinge angle in degrees</param>
            <param name="maxAngle">Maximum hinge angle in degrees</param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Joints.RevoluteJointBuilder.WithAngleMotor(System.Single,System.Single,System.Single)">
            <summary>
            Enables motor with angle target (Use angular spring to 'pull' towards target angle)
            </summary>
            <param name="targetAngle">Angular motor target angle</param>
            <param name="frequency">Angular motor frequency</param>
            <param name="dampingRatio">Angular motor damping ratio</param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Joints.RevoluteJointBuilder.WithVelocityMotor(System.Single,System.Single)">
            <summary>
            Enables motor with velocity target (Use torque to reach desired relative velocity)
            </summary>
            <param name="targetVelocity">Angular motor target velocity</param>
            <param name="maxTorque">Angular motor maximum torque to reach target velocity</param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Joints.RevoluteJointBuilder.Create">
            <summary>
            Finish creation of joint
            </summary>
        </member>
        <member name="M:Sandbox.Joints.SphericalJointBuilder.WithAngleMotor(Rotation,System.Single,System.Single)">
            <summary>
            Enables motor with angle target (Use angular spring to 'pull' towards target angle)
            </summary>
            <param name="targetRot">Angular motor target orientation</param>
            <param name="frequency">Angular motor frequency</param>
            <param name="dampingRatio">Angular motor damping ratio</param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Joints.SphericalJointBuilder.WithVelocityMotor(System.Single,System.Single)">
            <summary>
            Enables motor with velocity target (Use torque to reach desired relative velocity)
            </summary>
            <param name="targetVelocity">Angular motor target velocity</param>
            <param name="maxTorque">Angular motor maximum torque to reach target velocity</param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Joints.SphericalJointBuilder.Create">
            <summary>
            Finish creation of joint
            </summary>
        </member>
        <member name="M:Sandbox.Joints.SpringJointBuilder.Create">
            <summary>
            Finish creation of joint
            </summary>
        </member>
        <member name="M:Sandbox.Joints.WeldJointBuilder.Create">
            <summary>
            Finish creation of joint
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsJoint.IsConicalJoint">
            <summary>
            Is this a ConicalJoint
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsJoint.Conical">
            <summary>
            Start creation of Conical joint
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsJoint.op_Implicit(Sandbox.PhysicsJoint)~Sandbox.Joints.ConicalJoint">
            <summary>
            Implicit conversion to GenericJoint
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsJoint.IsGenericJoint">
            <summary>
            Is this a GenericJoint
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsJoint.Generic">
            <summary>
            Start creation of Generic joint
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsJoint.op_Implicit(Sandbox.PhysicsJoint)~Sandbox.Joints.GenericJoint">
            <summary>
            Implicit conversion to GenericJoint
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsJoint.IsPrismaticJoint">
            <summary>
            Is this a PrismaticJoint
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsJoint.Prismatic">
            <summary>
            Start creation of Prismatic joint
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsJoint.op_Implicit(Sandbox.PhysicsJoint)~Sandbox.Joints.PrismaticJoint">
            <summary>
            Implicit conversion to PrismaticJoint
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsJoint.IsRevoluteJoint">
            <summary>
            Is this a RevoluteJoint
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsJoint.Revolute">
            <summary>
            Start creation of Revolute joint
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsJoint.op_Implicit(Sandbox.PhysicsJoint)~Sandbox.Joints.RevoluteJoint">
            <summary>
            Implicit conversion to RevoluteJoint
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsJoint.IsSphericalJoint">
            <summary>
            Is this a SphericalJoint
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsJoint.Spherical">
            <summary>
            Start creation of Spherical joint
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsJoint.op_Implicit(Sandbox.PhysicsJoint)~Sandbox.Joints.SphericalJoint">
            <summary>
            Implicit conversion to SphericalJoint
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsJoint.IsSpringJoint">
            <summary>
            Is this a SpringJoint
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsJoint.Spring">
            <summary>
            Start creation of Spring joint
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsJoint.op_Implicit(Sandbox.PhysicsJoint)~Sandbox.Joints.SpringJoint">
            <summary>
            Implicit conversion to SpringJoint
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsJoint.IsWeldJoint">
            <summary>
            Is this a WeldJoint
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsJoint.Weld">
            <summary>
            Start creation of Weld joint
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsJoint.op_Implicit(Sandbox.PhysicsJoint)~Sandbox.Joints.WeldJoint">
            <summary>
            Implicit conversion to WeldJoint
            </summary>
        </member>
        <member name="M:Sandbox.Physics.GetPointContents(Vector3,System.Boolean)">
            <summary>
            Get what's at this point
            </summary>
        </member>
        <member name="M:Sandbox.Physics.TestPointContents(Vector3,Sandbox.CollisionLayer,System.Boolean)">
            <summary>
            Is this at this point
            </summary>
        </member>
        <member name="T:Sandbox.PhysicsBody">
            <summary>
            Represents a physics object. An entity can have multiple physics objects. See <see cref="P:Sandbox.PhysicsBody.PhysicsGroup">PhysicsGroup</see>.
            A physics objects conists of one or more <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see>s.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.EnableTouch">
            <summary>
            Allow Touch callbacks to be called
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.Wake">
            <summary>
            Wake up this physics body. Physics bodies automatically go to sleep after a certain amount of time of inactivity to save on performance.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.Sleep">
            <summary>
            Put this physics body to sleep. Physics bodies automatically go to sleep after a certain amount of time of inactivity to save on performance.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.IsSleeping">
            <summary>
            Returns the current sleep state of this physics body. Physics bodies automatically go to sleep after a certain amount of time of inactivity to save on performance.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.Parent">
            <summary>
            The physics body we are attached to, if any
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.PhysicsGroup">
            <summary>
            The physics group we belong to.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.Entity">
            <summary>
            The entity we belong to.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.SetSurface(System.String)">
            <summary>
            Sets a physical properties on all child <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see>s.
            </summary>
        </member>
        <member name="T:Sandbox.PhysicsGroup">
            <summary>
            Represets a set of <see cref="T:Sandbox.PhysicsBody">PhysicsBody</see> objects.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsGroup.Wake">
            <summary>
            Wake all physics bodies of this physics group. Physics bodies automatically go to sleep after a certain amount of time of inactivity to save on performance.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsGroup.Sleep">
            <summary>
            Put all physics bodies of this physics group to sleep. Physics bodies automatically go to sleep after a certain amount of time of inactivity to save on performance.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsGroup.SetSurface(System.String)">
            <summary>
            Sets the physical properties of each <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see> of this group.
            </summary>
        </member>
        <member name="T:Sandbox.PhysicsShape">
            <summary>
            Represents a basic, convex shape. A <see cref="T:Sandbox.PhysicsBody">PhysicsBody</see> consists of one or more of these.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.Body">
            <summary>
            The physics body we belong to.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsShape.EnableAllCollision">
            <summary>
            Enable contact, trace and touch
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsShape.DisableAllCollision">
            <summary>
            Disable contact, trace and touch
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.IsMeshShape">
            <summary>
            Is this a MeshShape
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.IsHullShape">
            <summary>
            Is this a HullShape
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.IsSphereShape">
            <summary>
            Is this a SphereShape
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.IsCapsuleShape">
            <summary>
            Is this a CapsuleShape
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsShape.UpdateMesh(System.Collections.Generic.List{Vector3},System.Collections.Generic.List{System.Int32})">
            <summary>
            Recreate the collision mesh (Only if this physics shape is type Mesh)
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsShape.UpdateMesh(System.Span{Vector3},System.Span{System.Int32})">
            <summary>
            Recreate the collision mesh (Only if this physics shape is type Mesh)
            </summary>
        </member>
        <member name="M:Sandbox.ConstantBuffer.Create``1(``0,System.Boolean)">
            <summary>
            Create a new constant buffer for shaders from a predefined struct
            </summary>
            <typeparam name="T">Underlying constant buffer struct</typeparam>
            <param name="inputStruct">Input starting constbuffer data</param>
            <param name="isDynamic">use dynamic constant buffer flag</param>
        </member>
        <member name="M:Sandbox.ConstantBuffer.Update``1(``0)">
            <summary>
            Updates the constant buffer contents. Note, the structure size needs to be identical to when the const buffer was first constructed
            </summary>
            <typeparam name="T"></typeparam>
            <param name="inputStruct"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Material.CreateCopy">
            <summary>
            Create a copy of this material
            </summary>
        </member>
        <member name="M:Sandbox.Material.OverrideTexture(System.String,Sandbox.Texture)">
            <summary>
            Override texture parameter (Color, Normal, etc)
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetBounds(Vector3,Vector3)">
            <summary>
            Set the render bounds of this mesh, default is infinite
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetVertexRange(System.Int32,System.Int32)">
            <summary>
            Set how many vertices this mesh draws (if there's no index buffer)
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetIndexRange(System.Int32,System.Int32)">
            <summary>
            Set how many indices this mesh draws
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.CreateIndexBuffer(System.Int32,System.Collections.Generic.List{System.Int32})">
            <summary>
            Create a index buffer with a number of indices
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.CreateIndexBuffer(System.Int32,System.Span{System.Int32})">
            <summary>
            Create a index buffer with a number of indices
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetIndexBufferData(System.Collections.Generic.List{System.Int32},System.Int32)">
            <summary>
            Set data of this buffer
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetIndexBufferData(System.Span{System.Int32},System.Int32)">
            <summary>
            Set data of this buffer
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetIndexBufferSize(System.Int32)">
            <summary>
            Resize the index buffer
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.LockIndexBuffer(Sandbox.Mesh.IndexBufferLockHandler)">
            <summary>
            Lock all the memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.LockIndexBuffer(System.Int32,Sandbox.Mesh.IndexBufferLockHandler)">
            <summary>
            Lock a specific amount of the memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.LockIndexBuffer(System.Int32,System.Int32,Sandbox.Mesh.IndexBufferLockHandler)">
            <summary>
            Lock a region of memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.CreateVertexBuffer``1(System.Int32,Sandbox.VertexAttribute[],System.Collections.Generic.List{``0})">
            <summary>
            Create a vertex buffer with a number of vertices, an array of vertex attributes can be passed in
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.CreateVertexBuffer``1(System.Int32,Sandbox.VertexAttribute[],System.Span{``0})">
            <summary>
            Create a vertex buffer with a number of vertices, an array of vertex attributes can be passed in
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetVertexBufferData``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Set data of this buffer
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetVertexBufferData``1(System.Span{``0},System.Int32)">
            <summary>
            Set data of this buffer
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetVertexBufferSize(System.Int32)">
            <summary>
            Resize the vertex buffer
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.LockVertexBuffer``1(Sandbox.Mesh.VertexBufferLockHandler{``0})">
            <summary>
            Lock all the memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.LockVertexBuffer``1(System.Int32,Sandbox.Mesh.VertexBufferLockHandler{``0})">
            <summary>
            Lock a specific amount of the memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.LockVertexBuffer``1(System.Int32,System.Int32,Sandbox.Mesh.VertexBufferLockHandler{``0})">
            <summary>
            Lock a region of memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="P:Sandbox.Model.Bounds">
            <summary>
            Total bounds of all the meshes
            </summary>
        </member>
        <member name="P:Sandbox.Model.PhysicsBounds">
            <summary>
            Total bounds of all the physics shapes
            </summary>
        </member>
        <member name="P:Sandbox.Model.RenderBounds">
            <summary>
            Render view bounds
            </summary>
        </member>
        <member name="M:Sandbox.Model.GetCollisionQuadBasis(Vector3@,Vector3@)">
            <summary>
            This is shit and only needed for func_shatterglass until we come up with a better way, please don't use
            </summary>
        </member>
        <member name="M:Sandbox.Model.GetBreakCommands">
            <summary>
            Internal function used to get a list of break commands the model has.
            </summary>
        </member>
        <member name="M:Sandbox.Model.TryGetData``1(``0@)">
            <summary>
            Tries to extract data from model based on the given type's [Library] attribute.
            </summary>
            <param name="data">The extracted data, or default on failure.</param>
            <returns>true if data was extracted successfully, false otherwise.</returns>
        </member>
        <member name="M:Sandbox.Model.HasData``1">
            <summary>
            Tests if this model has generic data based on given type's [Library] attribute.
            This will be faster than testing this via GetData<![CDATA[<>]]>()
            </summary>
        </member>
        <member name="M:Sandbox.Model.GetData``1">
            <summary>
            Extracts data from model based on the given type's [Library] attribute.
            </summary>
        </member>
        <member name="M:Sandbox.Model.GetAllData``1">
            <summary>
            Returns all game data nodes that derive from given class/interface, and are present on the model. Does NOT support data nodes that allow multiple entries.
            </summary>
        </member>
        <member name="M:Sandbox.Model.Get(NativeEngine.IModel)">
            <summary>
            Try to make it so only one Model class exists for each model
            </summary>
        </member>
        <member name="M:Sandbox.Model.GetVertices">
            <summary>
            Experimental! Try to get all vertices from model (meshes need to be compiled with CPU access!)
            https://files.facepunch.com/layla/1b0611b1/sbox_K1HhsZO3yM.png
            </summary>
        </member>
        <member name="M:Sandbox.Model.GetIndices">
            <summary>
            Experimental! Try to get all indices from model (meshes need to be compiled with CPU access!)
            https://files.facepunch.com/layla/1b0611b1/sbox_K1HhsZO3yM.png
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.WithMass(System.Single)">
            <summary>
            Total mass of the physics body (Default is 1000)
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.WithSurface(System.String)">
            <summary>
            Surface property to use for collision
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.WithLodDistance(System.Single)">
            <summary>
            LOD switch distance increment for each LOD level (Default is 50)
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddCollisionBox(Vector3,System.Nullable{Vector3},System.Nullable{Rotation})">
            <summary>
            Add box collision shape
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddCollisionSphere(System.Single,Vector3)">
            <summary>
            Add sphere collision shape
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddCollisionCapsule(Vector3,Vector3,System.Single)">
            <summary>
            Add capsule collision shape
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddCollisionHull(Vector3[],System.Nullable{Vector3},System.Nullable{Rotation})">
            <summary>
            Add a CONVEX hull collision shape
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddCollisionMesh(Vector3[],System.Int32[])">
            <summary>
            Add a CONCAVE mesh collision shape (This shape can NOT be physically simulated)
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddMesh(Sandbox.Mesh)">
            <summary>
            Add a mesh
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddMeshes(Sandbox.Mesh[])">
            <summary>
            Add a bunch of meshes
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddMesh(Sandbox.Mesh,System.Int32)">
            <summary>
            Add a mesh to a LOD group
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddMeshes(Sandbox.Mesh[],System.Int32)">
            <summary>
            Add a bunch of meshes to a LOD group
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddBone(System.String,Vector3,Rotation,System.String)">
            <summary>
            Add a bone to the skeleton
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.Create">
            <summary>
            Finish creation of model
            </summary>
        </member>
        <member name="M:Sandbox.BasePostProcess.NextPass">
            <summary>
            Flip the framebuffer or mark the current pass as complete. This is equivalent to
            adding a new layer to the post processing effects
            </summary>
        </member>
        <member name="M:Sandbox.BasePostProcess.Passthrough">
            <summary>
            Just copies the current source buffer to the output using the passthrough shader automatically
            </summary>
        </member>
        <member name="M:Sandbox.BasePostProcess.ScopedRenderTarget">
            <summary>
            Resets the framebuffer after the object is disposed. This is mainly useful when you want to render to a temp render target
            </summary>
        </member>
        <member name="T:Sandbox.PostProcessRTScope">
            <summary>
            Returns the post processing ColorBuffer, Viewport and Render Target back
            to the original settings for this pass. This is mainly used for rendering
            something to a texture on a pass
            </summary>
        </member>
        <member name="M:Sandbox.StandardPostProcess.OnFrame">
            <summary>
            We use this to monitor recreation of render targets on resolution changes. We can't do this in
            post processing because we cannot create textures in the render block
            </summary>
        </member>
        <member name="M:Sandbox.Render.GetDynamicVB(System.Boolean)">
            <summary>
            Get the vertex buffer
            </summary>
        </member>
        <member name="M:Sandbox.Render.CopyFrameBuffer(System.Boolean)">
            <summary>
            Grabs the current frame buffer and stores it in 'FrameBufferCopyTexture'
            </summary>
        </member>
        <member name="M:Sandbox.Render.CopyDepthBuffer">
            <summary>
            Grabs the current depth buffer and stores it in 'DepthBufferCopyTexture'
            </summary>
        </member>
        <member name="M:Sandbox.Render.CopyViewportBuffer(System.Boolean)">
            <summary>
            Grabs the current viewport buffer and stores it in 'FrameBufferCopyTexture'
            </summary>
        </member>
        <member name="M:Sandbox.Render.UI.TextStretched(Rect,Color,System.String,System.String,System.Single,Sandbox.BlendMode,System.Nullable{System.Single},System.Int32)">
            <summary>
            Draw text, stretched to fit inside the rect
            </summary>
        </member>
        <member name="M:Sandbox.Render.UI.Text(Vector3,Color,System.String,System.String,System.Single,Sandbox.BlendMode,System.Nullable{System.Single},System.Int32)">
            <summary>
            Draw text
            </summary>
        </member>
        <member name="M:Sandbox.RenderingManager.RenderUI">
            <summary>
            Called from render thread
            </summary>
        </member>
        <member name="T:Sandbox.TextManager">
            <summary>
            Render text at runtime
            </summary>
        </member>
        <member name="M:Sandbox.Texture.CopyFrom(Sandbox.Texture)">
            <summary>
            Replace our strong handle with a copy of the strong handle of the passed texture
            Which means that this texture will invisbly become that texture.
            I suspect that there might be a decent way to do this in native using the resource system.
            In which case we should change all this code to use that way instead of doing this.
            </summary>
        </member>
        <member name="P:Sandbox.Texture.Size">
            <summary>
            Returns a Vector2 representing the size of the texure (width, height)
            </summary>
        </member>
        <member name="M:Sandbox.Texture.Dispose">
            <summary>
            Will release the handle for this texture. If the texture isn't referenced by anything
            else it'll be released properly. This will happen anyway because it's called in the destructor.
            By calling it manually you're just telling the engine you're done with this texture right now
            instead of waiting for the garbage collector.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.LoadAsync(System.String,System.Boolean)">
            <summary>
            Load a texture asyncronously. Will return when the texture is loaded and valid.
            This is useful when loading textures from the web.
            </summary>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithUAVBinding">
            <summary>
            Support binding the texture as a Unordered Access View in a compute or pixel shader.
            This is required for binding a texture within a compute shader
            </summary>
            <returns>Texture2DBuilder</returns>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithUAVBinding">
            <summary>
            Support binding the texture as a Unordered Access View in a compute or pixel shader.
            This is required for binding a texture within a compute shader
            </summary>
            <returns>Texture3DBuilder</returns>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithUAVBinding">
            <summary>
            Support binding the texture as a Unordered Access View in a compute or pixel shader.
            This is required for binding a texture within a compute shader
            </summary>
            <returns>TextureArrayBuilder</returns>
        </member>
        <member name="M:Sandbox.TextureBuilder.WithUAVBinding">
            <summary>
            Support binding the texture as a Unordered Access View in a compute or pixel shader.
            This is required for binding a texture within a compute shader
            </summary>
            <returns>TextureBuilder</returns>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithUAVBinding">
            <summary>
            Support binding the texture as a Unordered Access View in a compute or pixel shader.
            This is required for binding a texture within a compute shader
            </summary>
            <returns>TextureCubeBuilder</returns>
        </member>
        <member name="F:Sandbox.TextureLoader.ImageUrl.Loaded">
            <summary>
            For textures loaded from the web we want to keep them around a bit longer
            </summary>
        </member>
        <member name="M:Sandbox.VertexBuffer.Add(Sandbox.Vertex)">
            <summary>
            Add a vertex
            </summary>
        </member>
        <member name="M:Sandbox.VertexBuffer.AddIndex(System.Int32)">
            <summary>
            Add an index. This is relative to the top of the vertex buffer. So 0 is Vertex.Count., 1 is Vertex.Count -1
            </summary>
        </member>
        <member name="M:Sandbox.VertexBuffer.AddTriangleIndex(System.Int32,System.Int32,System.Int32)">
            <summary>
            Add an index. This is relative to the top of the vertex buffer. So 0 is Vertex.Count.
            </summary>
        </member>
        <member name="M:Sandbox.VertexBuffer.AddRawIndex(System.Int32)">
            <summary>
            Add an index. This is relative to the top of the vertex buffer. So 0 is Vertex.Count.
            </summary>
        </member>
        <member name="M:Sandbox.VertexBuffer.Draw(Sandbox.Material)">
            <summary>
            Draw this mesh using Material
            </summary>
        </member>
        <member name="P:Sandbox.AnimSceneObject.AnimationTime">
            <summary>
            The current animation time.
            </summary>
        </member>
        <member name="M:Sandbox.AnimSceneObject.Update(System.Single)">
            <summary>
            Update this animation. Delta is the time you want to advance, usually RealTime.Delta
            </summary>
        </member>
        <member name="M:Sandbox.AnimSceneObject.SetMaterialGroup(System.String)">
            <summary>
            Set material group to replace materials of the model
            </summary>
        </member>
        <member name="M:Sandbox.AnimSceneObject.SetBodyGroup(System.String,System.Int32)">
            <summary>
            Set which body group to use
            </summary>
        </member>
        <member name="P:Sandbox.PanelSceneObject.ZBufferMode">
            <summary>
            Set an override for the Z buffer mode. This affects how depth tests and writes are handled when
            rendering this.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.SceneObjectFlagAccessor.ExcludeGameLayer">
            <summary>
            Don't render in the opaque/translucent game passes. This is useful when you
            want to only render in the Bloom layer, rather than additionally to it.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.SceneObjectFlagAccessor.WantsFrameBufferCopy">
            <summary>
            Automatically sets the "FrameBufferCopyTexture" attribute within the material.
            This does the same thing as Render.CopyFrameBuffer(); except automatically if
            the pass allows for it.
            </summary>
        </member>
        <member name="P:Sandbox.Streamer.Username">
            <summary>
            Your own username
            </summary>
        </member>
        <member name="P:Sandbox.Streamer.UserId">
            <summary>
            Your own user id
            </summary>
        </member>
        <member name="P:Sandbox.Streamer.Service">
            <summary>
            The service type (ie "Twitch")
            </summary>
        </member>
        <member name="P:Sandbox.Streamer.IsActive">
            <summary>
            Are we connected to a service
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.GetUser(System.String)">
            <summary>
            Get user infomation. If no username is specified, the user returned is ourself
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.GetUserFollowing(System.String)">
            <summary>
            Get user following "Who is X following"
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.GetUserFollowers(System.String)">
            <summary>
            Get user followers "Who is following X"
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.CreatePoll(System.String,System.String,System.Int32,System.String[])">
            <summary>
            Start a poll with choices, save the poll id so you can end it later on
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.EndPoll(System.String,System.String,System.Boolean)">
            <summary>
            End a poll using a saved poll id, you can optionally archive the poll or just terminate it
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.CreatePrediction(System.String,System.String,System.Int32,System.String,System.String)">
            <summary>
            Create a prediction to bet with channel points
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.LockPrediction(System.String,System.String)">
            <summary>
            Lock a current prediction with prediction id
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.CancelPrediction(System.String,System.String)">
            <summary>
            Cancel a current prediction with prediction id
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.ResolvePrediction(System.String,System.String,System.String)">
            <summary>
            Resolve a current prediction with prediction id and choose winning outcome to pay out channel points
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.SendMessage(System.String)">
            <summary>
            Send a message to chat, optionally specifiy channel you want to send the message, otherwise it is sent to your own chat
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.ClearChat">
            <summary>
            Clear your own chat
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.BanUser(System.String,System.String,System.Int32)">
            <summary>
            Ban user from your chat by username, the user will no longer be able to chat.
            Optionally specify the duration, a duration of zero means perm ban
            (Note: You have to be in your chat for this to work)
            </summary>
        </member>
        <member name="M:Sandbox.Streamer.UnbanUser(System.String)">
            <summary>
            Unban user from your chat by username
            (Note: You have to be in your chat for this to work)
            </summary>
        </member>
        <member name="P:Sandbox.Streamer.Game">
            <summary>
            Set the game you're playing by game id
            </summary>
        </member>
        <member name="P:Sandbox.Streamer.Language">
            <summary>
            Set the language of your stream
            </summary>
        </member>
        <member name="P:Sandbox.Streamer.Title">
            <summary>
            Set the title of your stream
            </summary>
        </member>
        <member name="P:Sandbox.Streamer.Delay">
            <summary>
            Set the delay of your stream
            </summary>
        </member>
        <member name="P:Sandbox.Time.Now">
            <summary>
            The time since game startup
            </summary>
        </member>
        <member name="P:Sandbox.Time.Delta">
            <summary>
            The delta between the last frame and the current (for all intents and purposes)
            </summary>
        </member>
        <member name="P:Sandbox.Time.Tick">
            <summary>
            The current tick number that is being simulated.
            </summary>
        </member>
        <member name="P:Sandbox.Time.Sound">
            <summary>
            Gets the current DSP time
            </summary>
        </member>
        <member name="P:Sandbox.Time.SoundDelta">
            <summary>
            Gets the current delta between two DSP frames
            </summary>
        </member>
        <member name="M:Sandbox.Trace.Sphere(System.Single,Vector3@,Vector3@)">
            <summary>
            Casts a sphere from point A to point B.
            </summary>
        </member>
        <member name="M:Sandbox.Trace.Sphere(System.Single,Ray@,System.Single@)">
            <summary>
            Casts a sphere from a given position and direction, up to a given distance.
            </summary>
        </member>
        <member name="M:Sandbox.Trace.Box(Vector3,Vector3@,Vector3@)">
            <summary>
            Casts a box from point A to point B.
            </summary>
        </member>
        <member name="M:Sandbox.Trace.Box(Vector3,Ray@,System.Single@)">
            <summary>
            Casts a box from a given position and direction, up to a given distance.
            </summary>
        </member>
        <member name="M:Sandbox.Trace.Box(BBox,Vector3@,Vector3@)">
            <summary>
            Casts a box from point A to point B.
            </summary>
        </member>
        <member name="M:Sandbox.Trace.Box(BBox,Ray@,System.Single@)">
            <summary>
            Casts a box from a given position and direction, up to a given distance.
            </summary>
        </member>
        <member name="M:Sandbox.Trace.Capsule(Capsule,Vector3@,Vector3@)">
            <summary>
            Casts a capsule from point A to point B.
            </summary>
        </member>
        <member name="M:Sandbox.Trace.Capsule(Capsule,Ray@,System.Single@)">
            <summary>
            Casts a capsule from a given position and direction, up to a given distance.
            </summary>
        </member>
        <member name="M:Sandbox.Trace.Ray(Vector3@,Vector3@)">
            <summary>
            Casts a ray from point A to point B.
            </summary>
        </member>
        <member name="M:Sandbox.Trace.Ray(Ray@,System.Single@)">
            <summary>
            Casts a ray from a given position and direction, up to a given distance.
            </summary>
        </member>
        <member name="M:Sandbox.Trace.Sweep(Sandbox.PhysicsBody@,Transform@,Transform@)">
            <summary>
            Sweeps each <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see> of given PhysicsBody and returns the closest collision. Does not support Mesh PhysicsShapes.
            Basically 'hull traces' but with physics shapes.
            </summary>
        </member>
        <member name="M:Sandbox.Trace.Sweep(Sandbox.PhysicsBody@,Transform@)">
            <summary>
            Creates a Trace.Sweep using the <see cref="T:Sandbox.PhysicsBody">PhysicsBody</see>'s position as the starting position.
            </summary>
        </member>
        <member name="M:Sandbox.Trace.FromTo(Vector3@,Vector3@)">
            <summary>
            Sets the start and end positions of the trace request
            </summary>
        </member>
        <member name="M:Sandbox.Trace.Ignore(Sandbox.Entity@,System.Boolean@)">
            <summary>
            Marks given entity to be ignored by the trace (the trace will go through it). Has a limit of 2 entities at this time.
            </summary>
        </member>
        <member name="M:Sandbox.Trace.WorldOnly">
            <summary>
            This trace should only hit the world, ignoring all entities.
            </summary>
        </member>
        <member name="M:Sandbox.Trace.EntitiesOnly">
            <summary>
            This trace should only hit entities, ignoring the world geometry.
            </summary>
        </member>
        <member name="M:Sandbox.Trace.WorldAndEntities">
            <summary>
            The trace should hit all entities and the world geometry.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Trace.Size(BBox@)">
            <summary>
            Makes this trace an axis aligned box of given size. Extracts mins and maxs from the Bounding Box.
            </summary>
        </member>
        <member name="M:Sandbox.Trace.Size(Vector3@)">
            <summary>
            Makes this trace an axis aligned box of given size. Calculates mins and maxs by assuming given size is (maxs-mins) and the center is in the middle.
            </summary>
        </member>
        <member name="M:Sandbox.Trace.Size(Vector3@,Vector3@)">
            <summary>
            Makes this trace an axis aligned box of given size.
            </summary>
        </member>
        <member name="M:Sandbox.Trace.Radius(System.Single)">
            <summary>
            Makes this trace a sphere of given radius.
            </summary>
        </member>
        <member name="M:Sandbox.Trace.UseHitboxes(System.Boolean)">
            <summary>
            Adds or removes <see cref="F:Sandbox.CollisionLayer.Hitbox">CollisionLayer.Hitbox</see> to the trace's mask
            </summary>
        </member>
        <member name="M:Sandbox.Trace.HitLayer(Sandbox.CollisionLayer,System.Boolean)">
            <summary>
            Adds or removes given <see cref="T:Sandbox.CollisionLayer">CollisionLayer</see> to the trace's mask
            </summary>
        </member>
        <member name="M:Sandbox.Trace.Run">
            <summary>
            Run the trace and return the result. The result will return the first hit.
            If the trace didn't hit then <see cref="F:Sandbox.TraceResult.Hit">TraceResult.Hit</see> will be false.
            </summary>
        </member>
        <member name="M:Sandbox.Trace.RunAll">
            <summary>
            Run the trace and return the results. This will return every entity hit in the
            order that they were hit. It will only hit each entity once.
            </summary>
        </member>
        <member name="M:Sandbox.Trace.WithTag(System.String)">
            <summary>
            Only return entities with this tag. Subsequent calls to this will add multiple requirements
            and they'll all have to be met (ie, the entity will need all tags).
            </summary>
        </member>
        <member name="M:Sandbox.Trace.WithAllTags(System.String[])">
            <summary>
            Only return entities with all of these tags
            </summary>
        </member>
        <member name="M:Sandbox.Trace.WithAnyTags(System.String[])">
            <summary>
            Only return entities with any of these tags
            </summary>
        </member>
        <member name="M:Sandbox.Trace.WithoutTags(System.String[])">
            <summary>
            Only return entities without any of these tags
            </summary>
        </member>
        <member name="F:Sandbox.TraceResult.Hit">
            <summary>
            Whether the trace hit something or not
            </summary>
        </member>
        <member name="F:Sandbox.TraceResult.StartedSolid">
            <summary>
            Whether the trace started in a solid
            </summary>
        </member>
        <member name="F:Sandbox.TraceResult.StartPos">
            <summary>
            The start position of the trace
            </summary>
        </member>
        <member name="F:Sandbox.TraceResult.EndPos">
            <summary>
            The end or hit position of the trace
            </summary>
        </member>
        <member name="F:Sandbox.TraceResult.Normal">
            <summary>
            The hit surface normal (direction vector)
            </summary>
        </member>
        <member name="F:Sandbox.TraceResult.Fraction">
            <summary>
            A fraction [0..1] of where the trace hit between the start and the original end positions
            </summary>
        </member>
        <member name="F:Sandbox.TraceResult.Entity">
            <summary>
            The entity that was hit, if any
            </summary>
        </member>
        <member name="F:Sandbox.TraceResult.Body">
            <summary>
            The physics object that was hit, if any
            </summary>
        </member>
        <member name="F:Sandbox.TraceResult.Shape">
            <summary>
            The physics shape that was hit, if any
            </summary>
        </member>
        <member name="F:Sandbox.TraceResult.HitboxIndex">
            <summary>
            The hitbox in current hitbox set that was hit, or -1. Requires <see cref="M:Sandbox.Trace.UseHitboxes(System.Boolean)">Trace.UseHitboxes</see> to work.
            </summary>
        </member>
        <member name="F:Sandbox.TraceResult.Surface">
            <summary>
            The physical properties of the hit surface
            </summary>
        </member>
        <member name="F:Sandbox.TraceResult.Bone">
            <summary>
            The id of the hit bone (either from hitbox or physics shape)
            </summary>
        </member>
        <member name="F:Sandbox.TraceResult.Direction">
            <summary>
            The direction of the trace ray
            </summary>
        </member>
        <member name="F:Sandbox.TraceResult.Triangle">
            <summary>
            The triangle index hit, if we hit a mesh shape
            </summary>
        </member>
        <member name="T:Sandbox.UI.DataSource.ArraySource">
            <summary>
            Bind a panel property to an object property ([Target].[TargetProperty])
            </summary>
        </member>
        <member name="F:Sandbox.UI.DataSource.ArraySource.Target">
            <summary>
            The target object to find the property
            </summary>
        </member>
        <member name="F:Sandbox.UI.DataSource.ArraySource.TargetIndex">
            <summary>
            Target index
            </summary>
        </member>
        <member name="P:Sandbox.UI.DataSource.BaseDataSource.PropertyName">
            <summary>
            Property on Panel to bind to.
            </summary>
        </member>
        <member name="F:Sandbox.UI.DataSource.BaseDataSource.Hash">
            <summary>
            Hash to store the last value in, to avoid unnesssary updates
            </summary>
        </member>
        <member name="P:Sandbox.UI.DataSource.BaseDataSource.Value">
            <summary>
            Implementable to get/set the value from the bound object
            </summary>
        </member>
        <member name="M:Sandbox.UI.DataSource.BaseDataSource.TryUpdateHash(System.Int32)">
            <summary>
            Returns true if the hash changed
            </summary>
        </member>
        <member name="M:Sandbox.UI.DataSource.BaseDataSource.Tick(Sandbox.UI.Panel)">
            <summary>
            Set the panel property from whatever the value is
            </summary>
        </member>
        <member name="T:Sandbox.UI.DataSource.BindClassMethod">
            <summary>
            Bind a panel property to a method
            </summary>
        </member>
        <member name="F:Sandbox.UI.DataSource.BindClassMethod.Target">
            <summary>
            The target object to find the property
            </summary>
        </member>
        <member name="F:Sandbox.UI.DataSource.BindClassMethod.TargetMethod">
            <summary>
            Method to get the value
            </summary>
        </member>
        <member name="T:Sandbox.UI.DataSource.BindMethod">
            <summary>
            Bind a panel property to a method
            </summary>
        </member>
        <member name="F:Sandbox.UI.DataSource.BindMethod.Target">
            <summary>
            The target object to find the property
            </summary>
        </member>
        <member name="F:Sandbox.UI.DataSource.BindMethod.TargetMethod">
            <summary>
            Method to get the value
            </summary>
        </member>
        <member name="T:Sandbox.UI.DataSource.ObjectProperty">
            <summary>
            Bind a panel property to an object property ([Target].[TargetProperty])
            </summary>
        </member>
        <member name="F:Sandbox.UI.DataSource.ObjectProperty.Target">
            <summary>
            The target object to find the property
            </summary>
        </member>
        <member name="F:Sandbox.UI.DataSource.ObjectProperty.TargetProperty">
            <summary>
            Target source, ie "PlayerName"
            </summary>
        </member>
        <member name="T:Sandbox.UI.DataSource.Property">
            <summary>
            Bind a panel property to an object's property
            </summary>
        </member>
        <member name="F:Sandbox.UI.DataSource.Property.Target">
            <summary>
            The target object to find the property
            </summary>
        </member>
        <member name="F:Sandbox.UI.DataSource.Property.TargetProperty">
            <summary>
            Target source, ie "PlayerName"
            </summary>
        </member>
        <member name="M:Sandbox.UI.Clipboard.SetText(System.String)">
            <summary>
            Sets the clipboard text
            </summary>
        </member>
        <member name="P:Sandbox.UI.ScenePanel.Ortho">
            <summary>
            Decides whether we should render the camera as an orthographic camera or a perspective camera
            </summary>
        </member>
        <member name="M:Sandbox.UI.LayoutCascade.ApplyCascading(Sandbox.UI.Styles)">
            <summary>
            Some properties cascade from their parent onto children if the children
            don't set them. Things like font size, color, cursor.
            </summary>
        </member>
        <member name="T:Sandbox.UI.TransitionDesc">
            <summary>
            Utility to create a transition by comparing the 
            panel style before and after the scope
            </summary>
        </member>
        <member name="T:Sandbox.UI.TransitionList">
            <summary>
            Utility to create a transition by comparing the 
            panel style before and after the scope
            </summary>
        </member>
        <member name="M:Sandbox.UI.FontManager.TryToLoad(System.String,System.Single,System.String)">
            <summary>
            Try to find this font on disk
            </summary>
        </member>
        <member name="M:Sandbox.UI.FontManager.WeightToText(System.Single)">
            <summary>
            Given a number, return the closest name weight
            </summary>
        </member>
        <member name="M:Sandbox.UI.SkiaTextBlock.Render(Sandbox.UI.PanelRenderer,Sandbox.UI.RenderState@,Sandbox.UI.Styles,Rect)">
            <summary>
            Proper Rendering
            </summary>
        </member>
        <member name="M:Sandbox.UI.SkiaTextBlock.SizeFinalized(System.Single,System.Single)">
            <summary>
            Called on layout. We should decide here if we actually need to rebuild
            </summary>
        </member>
        <member name="M:Sandbox.UI.SkiaTextBlock.RebuildTexture(System.Single,System.Single)">
            <summary>
            Actually recreate the texture
            </summary>
        </member>
        <member name="P:Sandbox.UI.Input.Hovered">
            <summary>
            Panel we're currently hovered over
            </summary>
        </member>
        <member name="P:Sandbox.UI.Input.Active">
            <summary>
            Panel we're currently pressing down
            </summary>
        </member>
        <member name="M:Sandbox.UI.Input.SetCursor(System.String)">
            <summary>
            The cursor should change. Name could be null, meaning default.
            </summary>
        </member>
        <member name="T:Sandbox.UI.WorldInput">
            <summary>
            WorldInput can be used to simulate standard mouse inputs on WorldPanels.
            </summary>
            <remarks>
            <para>
            You need to set <see cref="P:Sandbox.UI.WorldInput.Ray"/> and <see cref="P:Sandbox.UI.WorldInput.MouseLeftPressed"/> to simulate inputs,
            ideally this should be done in a BuildInput event.
            </para>
            <para>
            You can create this on your Pawn.
            </para>
            <para>
            A nice way to simulate world inputs for VR is to have a <see cref="T:Sandbox.UI.WorldInput"/> for each <see cref="T:Sandbox.Input.VrHand"/>.
            </para>
            </remarks>
        </member>
        <member name="P:Sandbox.UI.WorldInput.Enabled">
            <summary>
            This input won't tick when this is false.
            Any hovered panels will be cleared.
            </summary>
        </member>
        <member name="P:Sandbox.UI.WorldInput.Ray">
            <summary>
            The Ray used to intersect with your world panels, simulating mouse position.
            </summary>
            <remarks>
            This should ideally be set in BuildInput or FrameSimulate.
            
            <example>
            This could be your <see cref="P:Sandbox.Local.Pawn"/> EyePos and EyeDir:
            <code>
            WorldInput.Ray = new Ray( Local.Pawn.EyePos, Local.Pawn.EyeDir );
            </code>
            
            This could also be <see cref="P:Sandbox.Input.Cursor"/> if you want to use the mouse cursor.
            <code>
            WorldInput.Ray = Input.Cursor;
            </code>
            
            If using VR you may want to derive the Ray from a <see cref="T:Sandbox.Input.VrHand"/>.
            <code>
            WorldInput.Ray = new Ray( VRHand.Transform.Position, VRHand.Transform.Rotation.Forward );
            WorldInput.MouseLeftPressed = VRHand.Trigger.Active;
            </code>
            </example>
            </remarks>
        </member>
        <member name="P:Sandbox.UI.WorldInput.MouseLeftPressed">
            <summary>
            Simulate if the left mouse button is pressed.
            You can use <seealso cref="M:Sandbox.Input.Down(Sandbox.InputButton)"/>.
            </summary>
        </member>
        <member name="P:Sandbox.UI.WorldInput.MouseRightPressed">
            <summary>
            Simulate if the right mouse button is pressed.
            You can use <seealso cref="M:Sandbox.Input.Down(Sandbox.InputButton)"/>.
            </summary>
        </member>
        <member name="P:Sandbox.UI.WorldInput.MouseScroll">
            <summary>
            Simulate the mouse scroll wheel.
            You could use <seealso cref="P:Sandbox.Input.MouseWheel"/>
            Or you could simulate it with the camera view delta for example.
            </summary>
        </member>
        <member name="P:Sandbox.UI.WorldInput.UseMouseInput">
            <summary>
            Instead of simulating mouse input, this will simply use the mouse input.
            </summary>
        </member>
        <member name="P:Sandbox.UI.WorldInput.Hovered">
            <summary>
            The <see cref="T:Sandbox.UI.Panel"/> that is currently hovered by this input.
            </summary>
        </member>
        <member name="P:Sandbox.UI.WorldInput.Active">
            <summary>
            The <see cref="T:Sandbox.UI.Panel"/> that is currently pressed by this input.
            </summary>
        </member>
        <member name="F:Sandbox.UI.InputData.Mouse0">
            <summary>
            Left Mouse Button
            </summary>
        </member>
        <member name="F:Sandbox.UI.InputData.Mouse1">
            <summary>
            Muddle Mouse Button
            </summary>
        </member>
        <member name="F:Sandbox.UI.InputData.Mouse2">
            <summary>
            Right Mouse Button
            </summary>
        </member>
        <member name="F:Sandbox.UI.InputData.Mouse3">
            <summary>
            Back Button
            </summary>
        </member>
        <member name="F:Sandbox.UI.InputData.Mouse4">
            <summary>
            Forward Button
            </summary>
        </member>
        <member name="T:Sandbox.UI.InputEventQueue">
            <summary>
            Queue input events on here to be processed by the UISystem.
            </summary>
        </member>
        <member name="M:Sandbox.UI.InputFocus.Set(Sandbox.UI.Panel)">
            <summary>
            Set the focus to this panel (or its nearest ancestor with AcceptsFocus).
            Note that Current won't change until the next frame.
            </summary>
        </member>
        <member name="M:Sandbox.UI.InputFocus.Clear(Sandbox.UI.Panel)">
            <summary>
            Clear focus away from this panel.
            </summary>
        </member>
        <member name="F:Sandbox.UI.PanelStyle.activeRules">
            <summary>
            This could be a local variable if we wanted to create a new class every time
            </summary>
        </member>
        <member name="F:Sandbox.UI.PanelStyle.LastActiveRules">
            <summary>
            Store the last active rules so we can compare them when they change and trigger sounds etc on new styles
            </summary>
        </member>
        <member name="F:Sandbox.UI.PanelStyle.ActiveRulesGuid">
            <summary>
            Cache of the active rules that are applied, that way we can trigger stuff only if they actually changed
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.RemoveChild(Sandbox.UI.Panel)">
            <summary>
            Called internally when a child is removed, to remove from our Children list
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnChildRemoved(Sandbox.UI.Panel)">
            <summary>
            A child panel has been removed from this panel
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.AddChild(Sandbox.UI.Panel)">
            <summary>
            Add a child to this panel
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.InternalAddChild(Sandbox.UI.Panel)">
            <summary>
            Called internally when a child is added, to add to our Children list
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnChildAdded(Sandbox.UI.Panel)">
            <summary>
            A child panel has been added to this panel
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.SortChildren(System.Comparison{Sandbox.UI.Panel})">
            <summary>
            Sort the children using this comparison function
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.SortChildren``1(System.Func{``0,System.Int32})">
            <summary>
            Sort the children using this comparison function
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.SortChildren(System.Func{Sandbox.UI.Panel,System.Int32})">
            <summary>
            Sort the children using this comparison function
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.IsAncestor(Sandbox.UI.Panel)">
            <summary>
            Is the passed panel a parent, grandparent etc
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.Class">
            <summary>
            A list of classes applied to this panel
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.AddClass(System.String)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.RemoveClass(System.String)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.HasClass(System.String)">
            <summary>
            Returns true if we have this class
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.HasClasses(System.Collections.Generic.HashSet{System.String})">
            <summary>
            Returns true if we have all these classes
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.DirtyStylesRecursive">
            <summary>
            Dirty the styles of this class and its children recursively.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.BindClass(System.String,System.Func{System.Boolean})">
            <summary>
            Switch the class on or off depending on the value of the bool
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.ElementName">
            <summary>
            The element name. If you've created this Panel via a template this will be whatever the element
            name is on there. If not then it'll be the name of the class (ie Panel, Button)
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.PseudoClass">
            <summary>
            Special flags used by the styling system for hover, active etc..
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.Switch(Sandbox.UI.PseudoClass,System.Boolean)">
            <summary>
            Switch a pseudo class on or off
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.IsVisible">
            <summary>
            Return true if this panel isn't hidden by opacity or displaymode
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.IsVisibleSelf">
            <summary>
            Return true if this panel isn't hidden by opacity or displaymode
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnParentChanged">
            <summary>
            Called after the parent has changed
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.ScreenPositionToPanelDelta(Vector2)">
            <summary>
            Convert a point from the screen to a point representing a delta on this panel where
            the top left is [0,0] and the bottom right is [1,1]
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.ScreenPositionToPanelPosition(Vector2)">
            <summary>
            Convert a point from the screen to a position relative to the top left of this panel
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.PanelPositionToScreenPosition(Vector2)">
            <summary>
            Convert a point from local space to screen space
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.AllowChildSelection">
            <summary>
            Allow selecting child text
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.CreateValueEvent(System.String,System.Object)">
            <summary>
            Call this when the value has changed due to user input etc. This updates any
            bindings, backwards. Also triggers $"{name}.changed" event, with value being the Value on the event.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.Delete(System.Boolean)">
            <summary>
            Deletes the panel. If immediate is set, will skip any outros.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnDeleteRecursive">
            <summary>
            Called on delete
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.MousePosition">
            <summary>
            Current mouse position local to this panel
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.AcceptsFocus">
            <summary>
            False by default, can this element accept focus. If an element accepts
            focus it'll be able to recieve keyboard input.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.AcceptsImeInput">
            <summary>
            False by default. Anything that is capable of accepting IME input should return true. Which is probably just a TextEntry.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.Blur">
            <summary>
            Stop being the focus
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.GetClipboardValue(System.Boolean)">
            <summary>
            If we have a value that can be copied to the clipboard, return it here.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.UI.Panel.PushLayer(Sandbox.UI.PanelRenderer)">
            <summary>
            Called before rendering this panel
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.PopLayer(Sandbox.UI.PanelRenderer)">
            <summary>
            called after rendering this panel
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.LocalMatrix">
            <summary>
            If this panel has transforms, they'll be reflected here
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.GlobalMatrix">
            <summary>
            If this panel or its parents have transforms, they'll be compounded here.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnLayout(Rect@)">
            <summary>
            This panel has just been layed out. You can modify its position now and it will affect its children.
            This is a useful place to restrict shit to the the screen etc.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.FinalLayout">
            <summary>
            Takes a LayoutCascade and returns an outer rect
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.PreferScrollToBottom">
            <summary>
            If true, we'll try to stay scrolled to the bottom when the panel changes size
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.SetBindProperty(Sandbox.UI.Panel,System.String,System.String)">
            <summary>
            Binds that are generated via @ attributes in the templating system
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.Bind(System.String,System.Object,System.String)">
            <summary>
            Bind to the target object's property
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.Bind(Sandbox.UI.DataSource.BaseDataSource)">
            <summary>
            Bind to the data source
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.Bind(System.String,System.Func{System.Object})">
            <summary>
            Bind to the data source
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.SetRefProperty(Sandbox.UI.Panel,System.String,System.String)">
            <summary>
            Sets the field on context
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.SetContent(System.String)">
            <summary>
            Called by the templating system when an element has content between its tags.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnTemplateElement(Sandbox.Html.INode)">
            <summary>
            If you return true to this call the children from this element won't be created
            because we'll assume you're doing it youself in your control code
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.SetTemplate(System.String)">
            <summary>
            Set the panel's template. Ideally you won't be using this, you'll be 
            using the [UseTemplate] attribute instead.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.ComputedStyle">
            <summary>
            This is the style that we computed last. If you're looking to see which
            styles are set on this panel then this is what you're looking for.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.Style">
            <summary>
            Allows you to set styles specifically on this panel. Setting the style will
            only affect this panel and no others and will override any other styles.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.PreTemplateApplied">
            <summary>
            Called right before the template is applied.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.PostTemplateApplied">
            <summary>
            Called right after the template is applied
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.OnTemplateSlot(Sandbox.Html.INode,System.String,Sandbox.UI.Panel)">
            <summary>
            An element with a slot assigned has been created. This is assigned in the template 
            with the attribute slot="name". This is useful if you create panels programatically
            in your parent control and want to parent according to slots.
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.Transitions">
            <summary>
            Handles the storage, progression and application of style transitions
            </summary>
        </member>
        <member name="P:Sandbox.UI.Panel.HasActiveTransitions">
            <summary>
            Return true if this panel has any active transitions
            </summary>
        </member>
        <member name="M:Sandbox.UI.Panel.SkipTransitions">
            <summary>
            Any traisitons running, or about to run, will jump straight to the end
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleParser.ParseStyles(System.String,Sandbox.UI.Styles)">
            <summary>
            Parse the styles as you would if they were passed in an sytle="width: 100px" attribute
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleParser.Selector(System.String,Sandbox.UI.StyleBlock)">
            <summary>
            Here we divide the selectors into groups
            .fucker, .cocks, .hairy
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleParser.ParseSingleSelector(System.String,Sandbox.UI.StyleBlock)">
            <summary>
            Parse a single rule, which as "panel.closed.error:hover"
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.UI.BaseTextBlock.CaretRect(System.Int32)">
            <summary>
            Given a character position, where is the fucking caret
            </summary>
        </member>
        <member name="M:Sandbox.UI.PanelRenderer.Render(Sandbox.UI.Panel,Sandbox.UI.RenderState)">
            <summary>
            Render a panel
            </summary>
        </member>
        <member name="M:Sandbox.UI.PanelRenderer.DrawBoxShadow(Sandbox.UI.Panel,Sandbox.UI.RenderState@)">
            <summary>
            Should draw the box shadow, if your renderer supports this
            </summary>
        </member>
        <member name="P:Sandbox.UI.RootPanel.WantsMouseInput">
            <summary>
            If any of our panels are visible and want mouse input (pointer-events != none) then 
            this will be set to the first panel we find where that is the case
            </summary>
        </member>
        <member name="P:Sandbox.UI.RootPanel.RenderedManually">
            <summary>
            If set to true this panel won't be rendered to the screen like a normal panel.
            This is true when the panel is drawn via other means (like as a world panel)
            </summary>
        </member>
        <member name="P:Sandbox.UI.RootPanel.IsWorldPanel">
            <summary>
            Todo, this might need to exist
            </summary>
        </member>
        <member name="P:Sandbox.UI.RootPanel.IsVR">
            <summary>
            If this panel belongs to a <see cref="T:Sandbox.VROverlay"/>.
            </summary>
        </member>
        <member name="M:Sandbox.UI.RootPanel.UpdateBounds(Rect)">
            <summary>
            Called before layout to lock the bounds of this root panel to the screen size (which is passed).
            Internally this sets PanelBounds to rect and calls UpdateScale.
            </summary>
        </member>
        <member name="M:Sandbox.UI.RootPanel.UpdateScale(Rect)">
            <summary>
            Work out scaling here. Default is to scale relative to the screen being
            1920 wide. ie - scale = screensize.Width / 1920.0f;
            </summary>
        </member>
        <member name="F:Sandbox.UI.BorderImageRepeat.Stretch">
            <summary>
            The source image's edge regions are stretched to fill the gap between each border
            </summary>
        </member>
        <member name="F:Sandbox.UI.BorderImageRepeat.Round">
            <summary>
            The source image's edge regions are tiled (repeated) to fill the gap between each border. Tiles may be stretched to achieve the proper fit.
            </summary>
        </member>
        <member name="T:Sandbox.UI.StyleBlock">
            <summary>
            A CSS rule - ie ".chin { width: 100%; height: 100%; }"
            </summary>
        </member>
        <member name="F:Sandbox.UI.Justify.FlexStart">
            <summary>
            [OOOO            ]
            </summary>
        </member>
        <member name="F:Sandbox.UI.Justify.SpaceBetween">
            <summary>
            [O    O    O    O]
            </summary>
        </member>
        <member name="F:Sandbox.UI.TextSkipInk.All">
            <summary>
            Don't overlap any glyphs
            </summary>
        </member>
        <member name="F:Sandbox.UI.TextSkipInk.None">
            <summary>
            Overlap all glyphs
            </summary>
        </member>
        <member name="F:Sandbox.UI.TextDecorationStyle.Solid">
            <summary>
            Draw a single solid line
            </summary>
        </member>
        <member name="F:Sandbox.UI.TextDecorationStyle.Double">
            <summary>
            Draw two solid lines
            </summary>
        </member>
        <member name="F:Sandbox.UI.TextDecorationStyle.Dotted">
            <summary>
            Draw a dotted line
            </summary>
        </member>
        <member name="F:Sandbox.UI.TextDecorationStyle.Dashed">
            <summary>
            Draw a dashed line
            </summary>
        </member>
        <member name="F:Sandbox.UI.TextDecorationStyle.Wavy">
            <summary>
            Draw a wavy/squiggly line
            </summary>
        </member>
        <member name="F:Sandbox.UI.ColorInterpolation.Auto">
            <summary>
            Automatically pick between linear or lab based on the input
            </summary>
        </member>
        <member name="F:Sandbox.UI.ColorInterpolation.Linear">
            <summary>
            Linearly interpolate
            </summary>
        </member>
        <member name="F:Sandbox.UI.ColorInterpolation.Lab">
            <summary>
            Use the LAB color space for interpolation
            </summary>
        </member>
        <member name="T:Sandbox.UI.StyleSelector">
            <summary>
            A CSS selector like "Panel.button.red:hover .text"
            </summary>
        </member>
        <member name="F:Sandbox.UI.StyleSelector.Parent">
            <summary>
            Descendant combinator
            A B
            Child combinator
            A > B
            Adjacent sibling combinator
            A + B
            General sibling combinator
            A ~B
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleSheet.InitStyleSheets">
            <summary>
            Between sessions we clear the stylesheets, so one gamemode can't accidentally
            use cached values from another.
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleSheet.Release">
            <summary>
            Releases the filesystem watcher so we won't get file changed events.
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleSheetCollection.Add(Sandbox.UI.StyleSheet)">
            <summary>
            Add a stylesheet directly
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleSheetCollection.Load(System.String,System.Boolean)">
            <summary>
            Load the stylesheet from a file
            </summary>
        </member>
        <member name="M:Sandbox.UI.StyleSheetCollection.Parse(System.String,System.Boolean)">
            <summary>
            Load the stylesheet from a string
            </summary>
        </member>
        <member name="M:Sandbox.UI.PanelAction.Parse(System.String,System.String,System.Collections.Generic.List{Sandbox.UI.PanelAction})">
            <summary>
            Parse the code line into multiple PanelActions
            </summary>
        </member>
        <member name="T:Sandbox.UI.PanelAction.Argument">
            <summary>
            This is a mechanism to pass in possibly dynamic arguments
            </summary>
        </member>
        <member name="T:Sandbox.UI.PanelAction.StringLiteralArgument">
            <summary>
            A string literal means that the argument is just a static string, passed in 'liek this
            </summary>
        </member>
        <member name="T:Sandbox.UI.PanelAction.RuntimeArgument">
            <summary>
            A string literal means that the argument is just a static string, passed in 'liek this
            </summary>
        </member>
        <member name="T:Sandbox.UI.UseTemplateAttribute">
            <summary>
            If no name is passed, we will look next to the name of the file with this attribute
            </summary>
        </member>
        <member name="M:Sandbox.UI.Template.Apply(Sandbox.UI.Panel)">
            <summary>
            Applies the layout to this panel
            </summary>
        </member>
        <member name="M:Sandbox.UI.Template.ApplyStyles(Sandbox.UI.Panel)">
            <summary>
            Applies styles in this layout to this panel
            Since styles are applied to the root, this could
            and would obviously affect children too
            </summary>
        </member>
        <member name="M:Sandbox.UI.Template.Unapply(Sandbox.UI.Panel,System.Boolean)">
            <summary>
            Tries to remove the effects of this layout
            from this panel.
            </summary>
        </member>
        <member name="M:Sandbox.UI.Template.Forget(Sandbox.UI.Panel)">
            <summary>
            Stop tracking this panel as part of the layout.
            This means it'll stop getting notified of layout changes
            </summary>
        </member>
        <member name="M:Sandbox.UI.Template.RemoveStyles(Sandbox.UI.Panel)">
            <summary>
            Remove any styles applied by this layout
            </summary>
        </member>
        <member name="M:Sandbox.UI.Template.Load(System.String)">
            <summary>
            Load the layout from a string of html
            </summary>
        </member>
        <member name="M:Sandbox.UI.Template.AddStyleLink(System.String)">
            <summary>
            Adds a link to a stylesheet for this layout
            </summary>
        </member>
        <member name="M:Sandbox.UI.Template.AddStyleString(System.String)">
            <summary>
            Adds some raw css to our style for this layout
            </summary>
        </member>
        <member name="T:Sandbox.TaskGroup">
            <summary>
            Run a bunch of tasks in a thread, be able to wait until they're all finished
            </summary>
        </member>
        <member name="M:Sandbox.UISystem.AddDeferredDeletion(Sandbox.UI.Panel)">
            <summary>
            This panel should get deleted at some point
            </summary>
        </member>
        <member name="M:Sandbox.UISystem.RunDeferredDeletion(System.Boolean)">
            <summary>
            Delete all panels that were deferred and are no longer playing outro transitions
            </summary>
        </member>
        <member name="T:Sandbox.AddonProvision.Utility">
            <summary>
            Downloading and getting information about a specific addon.
            </summary>
            <summary>
            Downloading and getting information about a specific addon.
            </summary>
        </member>
        <member name="T:Sandbox.Easing">
            <summary>
            Easing functions used for transitions
            </summary>
        </member>
        <member name="T:Sandbox.Easing.Function">
            <summary>
            An easing function that transforms the linear input into non linear output.
            </summary>
            <param name="delta">A linear input value from 0 to 1</param>
            <returns>The resulting non linear output value, from 0 to 1</returns>
        </member>
        <member name="M:Sandbox.Easing.AddFunction(System.String,Sandbox.Easing.Function)">
            <summary>
            Add an easing function. 
            If the function already exists we silently return.
            </summary>
        </member>
        <member name="M:Sandbox.Easing.GetFunction(System.String)">
            <summary>
            Get an easing function by name (ie, "ease-in").
            If the function doesn't exist we return QuadraticInOut
            </summary>
        </member>
        <member name="T:Sandbox.ReflectionCache">
            <summary>
            This cache might be fucking stupid
            </summary>
        </member>
        <member name="M:Sandbox.ReflectionCache.GetAllMethods(System.Type,System.Collections.Generic.List{System.Reflection.MethodInfo},System.Collections.Generic.HashSet{System.String})">
            <summary>
            Get all methods in this type, including private ones, including repeats
            </summary>
        </member>
        <member name="M:Sandbox.Screen.GetDirection(Vector2)">
            <summary>
            Gives a direction vector based on the position of the point on the screen
            </summary>
        </member>
        <member name="M:Sandbox.Screen.GetDirection(Vector2,System.Single)">
            <summary>
            Gives a direction vector based on the position of the point on the screen
            </summary>
        </member>
        <member name="M:Sandbox.Screen.GetDirection(Vector2,System.Single,Rotation)">
            <summary>
            Gives a direction vector based on the position of the point on the screen
            </summary>
        </member>
        <member name="M:Sandbox.Screen.GetDirection(Vector2,System.Single,Rotation,Vector2)">
            <summary>
            Gives a direction vector based on the position of the point on the screen.
            </summary>
        </member>
        <member name="T:Sandbox.TaskSource">
            <summary>
            Provides a way for us to cancel tasks after common async shit is executed
            </summary>
        </member>
        <member name="T:Sandbox.VROverlay">
            <summary>
            <para>VR overlays draw over the top of the 3D scene, they will not be affected by lighting,
            post processing effects or anything else in the world.<br />
            This makes them ideal for HUDs or menus, or anything else that should be local to the
            HMD or tracked devices.</para>
            
            <para>If you need something in the world, consider using WorldPanel
            and <see cref="T:Sandbox.UI.WorldInput"/> instead.</para>
            </summary>
        </member>
        <member name="P:Sandbox.VROverlay.Visible">
            <summary>
            Shows or hides the VR overlay.
            </summary>
        </member>
        <member name="P:Sandbox.VROverlay.Transform">
            <summary>
            Sets the transform to absolute tracking origin
            </summary>
        </member>
        <member name="M:Sandbox.VROverlay.SetTransformAbsolute(Transform)">
            <summary>
            Sets the transform to absolute tracking origin
            </summary>
        </member>
        <member name="M:Sandbox.VROverlay.SetTransformRelative(Sandbox.VROverlay,Transform)">
            <summary>
            Sets the transform to relative to the transform of the specified overlay. This overlays visibility will also track the parents visibility.
            </summary>
        </member>
        <member name="P:Sandbox.VROverlay.Width">
            <summary>
            The width of the overlay quad.
            By default overlays are rendered on a quad that is 1 meter across.
            </summary>
        </member>
        <member name="P:Sandbox.VROverlay.Curvature">
            <summary>
            Use to draw overlay as a curved surface. Curvature is a percentage from (0..1] where 1 is a fully closed cylinder.
            For a specific radius, curvature can be computed as: overlay.width / (2 PI r).
            </summary>
        </member>
        <member name="P:Sandbox.VROverlay.Color">
            <summary>
            Sets the color tint of the overlay quad. Use 0.0 to 1.0 per channel.
            Sets the alpha of the overlay quad. Use 1.0 for 100 percent opacity to 0.0 for 0 percent opacity.
            </summary>
        </member>
        <member name="P:Sandbox.VROverlay.Texture">
            <summary>
            Texture that is rendered on the overlay quad.
            <see cref="T:Sandbox.TextureBuilder"/>
            </summary>
        </member>
        <member name="M:Sandbox.VROverlay.TriggerLaserMouseHapticVibration(System.Single,System.Single,System.Single)">
            <summary>
            Triggers a haptic event on the laser mouse controller for this overlay
            </summary>
        </member>
        <member name="T:Sandbox.VROverlayPanel">
            <summary>
            <para>A <see cref="T:Sandbox.VROverlay"/> that draws and handles input of a <see cref="T:Sandbox.UI.RootPanel"/>.</para>
            
            <para>VR overlays draw over the top of the 3D scene, they will not be affected by lighting,
            post processing effects or anything else in the world.<br />
            This makes them ideal for HUDs or menus, or anything else that should be local to the
            HMD or tracked devices.</para>
            
            <para>If you need something in the world, consider using WorldPanel
            and <see cref="T:Sandbox.UI.WorldInput"/> instead.</para>
            </summary>
        </member>
        <member name="T:Sandbox.WebSocket">
            <summary>
            A WebSocket client for connecting to external services.
            </summary>
            <remarks>
            Events handlers will be called on the synchronization context that <see cref="M:Sandbox.WebSocket.Connect(System.String,System.Threading.CancellationToken)"/> was called on.
            </remarks>
        </member>
        <member name="T:Sandbox.WebSocket.MessageReceivedHandler">
            <summary>
            Event handler which processes text messages from the WebSocket service.
            </summary>
            <param name="message">The message text that was received.</param>
        </member>
        <member name="T:Sandbox.WebSocket.DataReceivedHandler">
            <summary>
            Event handler which processes binary messages from the WebSocket service.
            </summary>
            <param name="data">The binary message data that was received.</param>
        </member>
        <member name="T:Sandbox.WebSocket.DisconnectedHandler">
            <summary>
            Event handler which fires when the WebSocket disconnects from the server.
            </summary>
            <param name="status">The close status code from the server, or 0 if there was none. See known values here: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent</param>
            <param name="reason">The reason string for closing the connection. This may not be populated, may be from the server, or may be a client exception message.</param>
        </member>
        <member name="P:Sandbox.WebSocket.IsConnected">
            <summary>
            Returns true as long as a WebSocket connection is established.
            </summary>
        </member>
        <member name="P:Sandbox.WebSocket.SubProtocol">
            <summary>
            Get the sub-protocol that was negotiated during the opening handshake.
            </summary>
        </member>
        <member name="E:Sandbox.WebSocket.OnMessageReceived">
            <summary>
            Event which fires when a text message is received from the server.
            </summary>
        </member>
        <member name="E:Sandbox.WebSocket.OnDataReceived">
            <summary>
            Event which fires when a binary message is received from the server.
            </summary>
        </member>
        <member name="E:Sandbox.WebSocket.OnDisconnected">
            <summary>
            Event which fires when the connection to the WebSocket service is lost, for any reason.
            </summary>
        </member>
        <member name="M:Sandbox.WebSocket.#ctor(System.Int32)">
            <summary>
            Initialized a new WebSocket client.
            </summary>
            <param name="maxMessageSize">The maximum message size to allow from the server, in bytes. Default 64 KiB.</param>
        </member>
        <member name="M:Sandbox.WebSocket.Dispose">
            <summary>
            Cleans up resources used by the WebSocket client. This will also immediately close the connection if it is currently open.
            </summary>
        </member>
        <member name="M:Sandbox.WebSocket.AddSubProtocol(System.String)">
            <summary>
            Add a sub-protocol to be negotiated during the WebSocket connection handshake.
            </summary>
            <param name="protocol"></param>
        </member>
        <member name="M:Sandbox.WebSocket.Connect(System.String,System.Threading.CancellationToken)">
            <summary>
            Establishes a connection to an external WebSocket service.
            </summary>
            <param name="websocketUri">The WebSocket URI to connect to. For example, "ws://hostname.local:1280/" for unencrypted WebSocket or "wss://hostname.local:1281/" for encrypted.</param>
            <param name="ct">A <see cref="T:System.Threading.CancellationToken"/> which allows the connection attempt to be aborted if necessary.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> which completes when the connection is established, or throws if it failed to connect.</returns>
        </member>
        <member name="M:Sandbox.WebSocket.Send(System.String)">
            <summary>
            Sends a text message to the WebSocket server.
            </summary>
            <param name="message">The message text to send. Must not be null.</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> which completes when the message was queued to be sent.</returns>
        </member>
        <member name="M:Sandbox.WebSocket.Send(System.Byte[])">
            <summary>
            Sends a binary message to the WebSocket server.
            </summary>
            <remarks>
            The <see cref="M:Sandbox.WebSocket.Send(System.ArraySegment{System.Byte})"/> and <see cref="M:Sandbox.WebSocket.Send(System.Span{System.Byte})"/> overloads allow sending subsections of byte arrays.
            </remarks>
            <param name="data">The message data to send. Must not be null.</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> which completes when the message was queued to be sent.</returns>
        </member>
        <member name="M:Sandbox.WebSocket.Send(System.ArraySegment{System.Byte})">
            <summary>
            Sends a binary message to the WebSocket server.
            </summary>
            <param name="data">The message data to send. Must not be null.</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> which completes when the message was queued to be sent.</returns>
        </member>
        <member name="M:Sandbox.WebSocket.Send(System.Span{System.Byte})">
            <summary>
            Sends a binary message to the WebSocket server.
            </summary>
            <param name="data">The message data to send.</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> which completes when the message was queued to be sent.</returns>
        </member>
        <member name="F:NativeEngine.ESceneObjectTypeFlags.SHOULD_BE_DELETED_BEFORE_WORLD">
            For objects that can't be considered to be "owned" by the world they are in because they
            are owned by a manager. All this flag does is cause a warning when such an object is still
            in the world at world deletion time (a leak).
        </member>
        <member name="F:NativeEngine.ESceneObjectTypeFlags.OWNED_BY_ANOTHER_SCENEOBJECT">
            if this flag is set, then the object will not be deleted when deleting the world, and will not be queued for delete. It's assumed that this object is going to be deleted inside of the destructor of another sceneobject
        </member>
        <member name="F:NativeEngine.ESceneObjectTypeFlags.PARTIALLY_ALPHA_BLENDED">
            We have a mixture of alpha-blended and non-alpha blended draws
        </member>
        <member name="F:NativeEngine.ESceneObjectTypeFlags.UNIQUE_BATCH_GROUP">
            A unique batch flag that allows objects to draw in a separate batch from their original group
        </member>
        <member name="F:NativeEngine.TraceRequest.ResolveEntities">
            <summary>
            If true, we use a slightly slower path in the trace code that checks each entity.
            This is needed for testing things like Tags, so gets set automatically if needed.
            </summary>
        </member>
        <member name="M:GameServices.Leaderboard.Query(System.String,System.Nullable{System.Int64},System.String,System.Nullable{System.Int64},System.Nullable{System.Int64})">
            <summary>
            Query the API for leaderboard entries
            </summary>
        </member>
        <member name="M:GameServices.EndGame">
            <summary>
            End the game. Submit and clear scores.
            </summary>
        </member>
        <member name="M:GameServices.RecordScore(System.Int64,System.Boolean,Sandbox.GameplayResult,System.Single)">
            <summary>
            Record this player's score
            </summary>
        </member>
        <member name="M:GameServices.AbandonGame(System.Boolean)">
            <summary>
            Abandon the game. Set playerLeave to true if the game was ended because 
            a player left and they should probably be pubished for it.
            </summary>
        </member>
        <member name="M:GameServices.StartGame">
            <summary>
            Start the game. Start recording shit.
            </summary>
        </member>
        <member name="M:GameServices.RecordEvent(Sandbox.Client,System.String,System.Nullable{System.Int32},Sandbox.Client)">
            <summary>
            Record a game event (for diagnostic reasons)
            </summary>
        </member>
        <member name="M:GameServices.RecordEvent(System.Int64,System.String,System.Nullable{System.Int32},System.Nullable{System.Int64})">
            <summary>
            Record a game event (for diagnostic reasons)
            </summary>
        </member>
        <member name="M:GameServices.PlayerLeave(System.Int64)">
            <summary>
            A player left the game
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandboclient_Physcs_OnObjectCreated(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.PhysicsBody.OnObjectCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandboclient_Physcs_OnObjectDestroyed(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.PhysicsBody.OnObjectDestroyed( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandboclient_Physcs_f2(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.PhysicsGroup.OnObjectCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandboclient_Physcs_f3(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.PhysicsGroup.OnObjectDestroyed( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandboclient_Physcs_f4(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.PhysicsJoint.OnObjectCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandboclient_Physcs_f5(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.PhysicsJoint.OnObjectDestroyed( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandboclient_Physcs_f6(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.PhysicsShape.OnObjectCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandboclient_Physcs_f7(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.PhysicsShape.OnObjectDestroyed( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandboclient_SceneO_OnObjectCreated(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.SceneObject.OnObjectCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandboclient_SceneO_OnObjectDestroyed(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.SceneObject.OnObjectDestroyed( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandboclient_SceneW_OnObjectCreated(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.SceneWorld.OnObjectCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandboclient_SceneW_OnObjectDestroyed(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.SceneWorld.OnObjectDestroyed( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_OnNativeEntity(System.UInt32,System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.OnNativeEntity( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalDestruct(System.UInt32)">
            <summary>
            Sandbox.ClientEntity.InternalDestruct( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalUpdateOnRemove(System.UInt32)">
            <summary>
            Sandbox.ClientEntity.InternalUpdateOnRemove( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_EnterPVSInternal(System.UInt32)">
            <summary>
            Sandbox.ClientEntity.EnterPVSInternal( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_LeavePVSInternal(System.UInt32)">
            <summary>
            Sandbox.ClientEntity.LeavePVSInternal( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalClientCreated(System.UInt32)">
            <summary>
            Sandbox.ClientEntity.InternalClientCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalClientActivate(System.UInt32)">
            <summary>
            Sandbox.ClientEntity.InternalClientActivate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalEntityKeyValue(System.UInt32,System.UInt32,System.IntPtr,System.Int32)">
            <summary>
            Sandbox.ClientEntity.InternalEntityKeyValue( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalEntityConnection(System.UInt32,System.IntPtr,System.Int64,System.IntPtr,System.IntPtr,System.IntPtr,System.Single,System.Int32)">
            <summary>
            Sandbox.ClientEntity.InternalEntityConnection( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalSpawn(System.UInt32)">
            <summary>
            Sandbox.ClientEntity.InternalSpawn( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalStartTouch(System.UInt32,System.UInt32)">
            <summary>
            Sandbox.ClientEntity.InternalStartTouch( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalOnTouch(System.UInt32,System.UInt32)">
            <summary>
            Sandbox.ClientEntity.InternalOnTouch( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalEndTouch(System.UInt32,System.UInt32)">
            <summary>
            Sandbox.ClientEntity.InternalEndTouch( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalOnParentChanged(System.UInt32,System.UInt32)">
            <summary>
            Sandbox.ClientEntity.InternalOnParentChanged( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalPreDataUpdate(System.UInt32)">
            <summary>
            Sandbox.ClientEntity.InternalPreDataUpdate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalPostDataUpdate(System.UInt32,System.Int32)">
            <summary>
            Sandbox.ClientEntity.InternalPostDataUpdate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalNetworkVariableChanged(System.UInt32,System.Int32,System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Sandbox.ClientEntity.InternalNetworkVariableChanged( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalOnNewModel(System.UInt32)">
            <summary>
            Sandbox.ClientEntity.InternalOnNewModel( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalAnimEvent(System.UInt32,System.IntPtr,System.Int32,System.Single,Vector3,System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalAnimEvent( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalAnimEventFootstep(System.UInt32,Vector3,System.Int32,System.Single)">
            <summary>
            Sandbox.ClientEntity.InternalAnimEventFootstep( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalPostClientActive(System.UInt32)">
            <summary>
            Sandbox.ClientEntity.InternalPostClientActive( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalOnSequenceFinished(System.UInt32,System.Int32)">
            <summary>
            Sandbox.ClientEntity.InternalOnSequenceFinished( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalOnNewSequence(System.UInt32)">
            <summary>
            Sandbox.ClientEntity.InternalOnNewSequence( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_PredictionStore(System.UInt32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sandbox.ClientEntity.PredictionStore( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_PredictionRestore(System.UInt32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sandbox.ClientEntity.PredictionRestore( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_PredictionVerify(System.UInt32,System.Int32,System.Int32)">
            <summary>
            Sandbox.ClientEntity.PredictionVerify( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_PredictionDestroy(System.UInt32)">
            <summary>
            Sandbox.ClientEntity.PredictionDestroy( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_PredictionShift(System.UInt32,System.Int32)">
            <summary>
            Sandbox.ClientEntity.PredictionShift( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalMoveDone(System.UInt32)">
            <summary>
            Sandbox.ClientEntity.InternalMoveDone( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalMoveBlocked(System.UInt32,System.UInt32)">
            <summary>
            Sandbox.ClientEntity.InternalMoveBlocked( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalOnSetDormant(System.UInt32,System.Int32)">
            <summary>
            Sandbox.ClientEntity.InternalOnSetDormant( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalPhysicsCollisionEvent(System.UInt32,System.UInt32,Vector3,Vector3,Vector3,Vector3,Vector3,Vector3,System.Single)">
            <summary>
            Sandbox.ClientEntity.InternalPhysicsCollisionEvent( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_PlayerSetupVisibility(System.UInt32,System.Int32,System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.PlayerSetupVisibility( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalOnAnimGraphTag(System.UInt32,System.IntPtr,System.Int32)">
            <summary>
            Sandbox.ClientEntity.InternalOnAnimGraphTag( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalOnAnimGraphCreated(System.UInt32)">
            <summary>
            Sandbox.ClientEntity.InternalOnAnimGraphCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_ClentE_InternalOnNameChanged(System.UInt32,System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalOnNameChanged( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_CnsleS_DispatchCommand(System.IntPtr,System.IntPtr,System.Int64,System.Int32)">
            <summary>
            Sandbox.ConsoleSystem.DispatchCommand( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_OnNativeEntity(System.UInt32,System.IntPtr)">
            <summary>
            Sandbox.Entity.OnNativeEntity( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalDestruct(System.UInt32)">
            <summary>
            Sandbox.Entity.InternalDestruct( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalUpdateOnRemove(System.UInt32)">
            <summary>
            Sandbox.Entity.InternalUpdateOnRemove( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_EnterPVSInternal(System.UInt32)">
            <summary>
            Sandbox.Entity.EnterPVSInternal( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_LeavePVSInternal(System.UInt32)">
            <summary>
            Sandbox.Entity.LeavePVSInternal( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalClientCreated(System.UInt32)">
            <summary>
            Sandbox.Entity.InternalClientCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalClientActivate(System.UInt32)">
            <summary>
            Sandbox.Entity.InternalClientActivate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalEntityKeyValue(System.UInt32,System.UInt32,System.IntPtr,System.Int32)">
            <summary>
            Sandbox.Entity.InternalEntityKeyValue( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalEntityConnection(System.UInt32,System.IntPtr,System.Int64,System.IntPtr,System.IntPtr,System.IntPtr,System.Single,System.Int32)">
            <summary>
            Sandbox.Entity.InternalEntityConnection( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalSpawn(System.UInt32)">
            <summary>
            Sandbox.Entity.InternalSpawn( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalStartTouch(System.UInt32,System.UInt32)">
            <summary>
            Sandbox.Entity.InternalStartTouch( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalOnTouch(System.UInt32,System.UInt32)">
            <summary>
            Sandbox.Entity.InternalOnTouch( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalEndTouch(System.UInt32,System.UInt32)">
            <summary>
            Sandbox.Entity.InternalEndTouch( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalOnParentChanged(System.UInt32,System.UInt32)">
            <summary>
            Sandbox.Entity.InternalOnParentChanged( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalPreDataUpdate(System.UInt32)">
            <summary>
            Sandbox.Entity.InternalPreDataUpdate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalPostDataUpdate(System.UInt32,System.Int32)">
            <summary>
            Sandbox.Entity.InternalPostDataUpdate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalNetworkVariableChanged(System.UInt32,System.Int32,System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Sandbox.Entity.InternalNetworkVariableChanged( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalOnNewModel(System.UInt32)">
            <summary>
            Sandbox.Entity.InternalOnNewModel( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalAnimEvent(System.UInt32,System.IntPtr,System.Int32,System.Single,Vector3,System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalAnimEvent( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalAnimEventFootstep(System.UInt32,Vector3,System.Int32,System.Single)">
            <summary>
            Sandbox.Entity.InternalAnimEventFootstep( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalPostClientActive(System.UInt32)">
            <summary>
            Sandbox.Entity.InternalPostClientActive( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalOnSequenceFinished(System.UInt32,System.Int32)">
            <summary>
            Sandbox.Entity.InternalOnSequenceFinished( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalOnNewSequence(System.UInt32)">
            <summary>
            Sandbox.Entity.InternalOnNewSequence( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_PredictionStore(System.UInt32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sandbox.Entity.PredictionStore( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_PredictionRestore(System.UInt32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sandbox.Entity.PredictionRestore( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_PredictionVerify(System.UInt32,System.Int32,System.Int32)">
            <summary>
            Sandbox.Entity.PredictionVerify( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_PredictionDestroy(System.UInt32)">
            <summary>
            Sandbox.Entity.PredictionDestroy( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_PredictionShift(System.UInt32,System.Int32)">
            <summary>
            Sandbox.Entity.PredictionShift( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalMoveDone(System.UInt32)">
            <summary>
            Sandbox.Entity.InternalMoveDone( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalMoveBlocked(System.UInt32,System.UInt32)">
            <summary>
            Sandbox.Entity.InternalMoveBlocked( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalOnSetDormant(System.UInt32,System.Int32)">
            <summary>
            Sandbox.Entity.InternalOnSetDormant( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalPhysicsCollisionEvent(System.UInt32,System.UInt32,Vector3,Vector3,Vector3,Vector3,Vector3,Vector3,System.Single)">
            <summary>
            Sandbox.Entity.InternalPhysicsCollisionEvent( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_PlayerSetupVisibility(System.UInt32,System.Int32,System.IntPtr)">
            <summary>
            Sandbox.Entity.PlayerSetupVisibility( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalOnAnimGraphTag(System.UInt32,System.IntPtr,System.Int32)">
            <summary>
            Sandbox.Entity.InternalOnAnimGraphTag( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalOnAnimGraphCreated(System.UInt32)">
            <summary>
            Sandbox.Entity.InternalOnAnimGraphCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Entity_InternalOnNameChanged(System.UInt32,System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalOnNameChanged( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_EnttyM_CreateServerEntity(System.IntPtr)">
            <summary>
            Sandbox.EntityManager.CreateServerEntity( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_EnttyM_CreateClientsideOfNetworkedEntity(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.EntityManager.CreateClientsideOfNetworkedEntity( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_Init">
            <summary>
            Sandbox.GameLoop.Init( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_PreOnActivate">
            <summary>
            Sandbox.GameLoop.PreOnActivate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_PostOnActivate">
            <summary>
            Sandbox.GameLoop.PostOnActivate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_OnDeactivate">
            <summary>
            Sandbox.GameLoop.OnDeactivate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_LoopShutdown">
            <summary>
            Sandbox.GameLoop.LoopShutdown( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_ClientPutInServer(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Sandbox.GameLoop.ClientPutInServer( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_ClientDisconnected(System.Int32,System.Int32,System.IntPtr,System.UInt64,System.IntPtr)">
            <summary>
            Sandbox.GameLoop.ClientDisconnected( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_OnClientPreOutput">
            <summary>
            Sandbox.GameLoop.OnClientPreOutput( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_OnClientPostOutput">
            <summary>
            Sandbox.GameLoop.OnClientPostOutput( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_NotifyDisconnect(System.Int32,System.IntPtr)">
            <summary>
            Sandbox.GameLoop.NotifyDisconnect( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_GetView(System.IntPtr)">
            <summary>
            Sandbox.GameLoop.GetView( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_PreRender">
            <summary>
            Sandbox.GameLoop.PreRender( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_UpdateAudioListener(System.IntPtr)">
            <summary>
            Sandbox.GameLoop.UpdateAudioListener( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_PhysicsThink">
            <summary>
            Sandbox.GameLoop.PhysicsThink( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_PrePhysicsStep(System.Single)">
            <summary>
            Sandbox.GameLoop.PrePhysicsStep( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_PostPhysicsStep(System.Single)">
            <summary>
            Sandbox.GameLoop.PostPhysicsStep( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_PhysicsImpactSound(System.Int32,Vector3,System.Single,System.Single,System.Int32,System.Int32)">
            <summary>
            Sandbox.GameLoop.PhysicsImpactSound( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_OnPhysicsJointBreak(System.Int32)">
            <summary>
            Sandbox.GameLoop.OnPhysicsJointBreak( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_RunBotCommands">
            <summary>
            Sandbox.GameLoop.RunBotCommands( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_ServerFrame_Think">
            <summary>
            Sandbox.GameLoop.ServerFrame_Think( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_ClientFrame_Think">
            <summary>
            Sandbox.GameLoop.ClientFrame_Think( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_PostEntitySpawn">
            <summary>
            Sandbox.GameLoop.PostEntitySpawn( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_Server_GetTimeScale">
            <summary>
            Sandbox.GameLoop.Server_GetTimeScale( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_Server_GetTickRate">
            <summary>
            Sandbox.GameLoop.Server_GetTickRate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_OnFrameSimulateStart">
            <summary>
            Sandbox.GameLoop.OnFrameSimulateStart( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_OnFrameSimulateEnd">
            <summary>
            Sandbox.GameLoop.OnFrameSimulateEnd( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_GameLo_OnModelReloaded(System.IntPtr)">
            <summary>
            Sandbox.GameLoop.OnModelReloaded( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_InptBl_Process(System.IntPtr)">
            <summary>
            Sandbox.InputBuilder.Process( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Netwrk_OnNetMessage(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Sandbox.Networking.OnNetMessage( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_PlyerC_RunClient(System.UInt32,System.IntPtr)">
            <summary>
            Sandbox.PlayerCommand.RunClient( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_PlyerC_RunClientFrame(System.IntPtr)">
            <summary>
            Sandbox.PlayerCommand.RunClientFrame( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_PlyerC_RunServer(System.UInt32,System.IntPtr)">
            <summary>
            Sandbox.PlayerCommand.RunServer( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Predct_PreEntityPacketReceived(System.Int32,System.Int32)">
            <summary>
            Sandbox.Prediction.PreEntityPacketReceived( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Predct_PostEntityPacketReceived">
            <summary>
            Sandbox.Prediction.PostEntityPacketReceived( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_RelTme_Update(System.Single)">
            <summary>
            Sandbox.RealTime.Update( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Render_RenderUI">
            <summary>
            Sandbox.RenderingManager.RenderUI( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Render_RenderSceneObject(System.Int32)">
            <summary>
            Sandbox.RenderingManager.RenderSceneObject( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Render_BlockStart(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.RenderingManager.BlockStart( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Render_BlockEnd">
            <summary>
            Sandbox.RenderingManager.BlockEnd( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Render_PostProcess">
            <summary>
            Sandbox.RenderingManager.PostProcess( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_StrngT_Init">
            <summary>
            Sandbox.StringTables.Init( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_StrngT_Shutdown">
            <summary>
            Sandbox.StringTables.Shutdown( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Sandbo_Time_Update(System.Single,System.Single,System.Int32)">
            <summary>
            Sandbox.Time.Update( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceClient.Exports.Stemwr_Dsptch_OnClientCallback(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Steamworks.Dispatch.OnClientCallback( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_OnNativeEntity(System.UInt32,System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.OnNativeEntity( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalDestruct(System.UInt32)">
            <summary>
            Sandbox.ClientEntity.InternalDestruct( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalUpdateOnRemove(System.UInt32)">
            <summary>
            Sandbox.ClientEntity.InternalUpdateOnRemove( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_EnterPVSInternal(System.UInt32)">
            <summary>
            Sandbox.ClientEntity.EnterPVSInternal( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_LeavePVSInternal(System.UInt32)">
            <summary>
            Sandbox.ClientEntity.LeavePVSInternal( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalClientCreated(System.UInt32)">
            <summary>
            Sandbox.ClientEntity.InternalClientCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalClientActivate(System.UInt32)">
            <summary>
            Sandbox.ClientEntity.InternalClientActivate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalEntityKeyValue(System.UInt32,System.UInt32,System.IntPtr,System.Int32)">
            <summary>
            Sandbox.ClientEntity.InternalEntityKeyValue( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalEntityConnection(System.UInt32,System.IntPtr,System.Int64,System.IntPtr,System.IntPtr,System.IntPtr,System.Single,System.Int32)">
            <summary>
            Sandbox.ClientEntity.InternalEntityConnection( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalSpawn(System.UInt32)">
            <summary>
            Sandbox.ClientEntity.InternalSpawn( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalStartTouch(System.UInt32,System.UInt32)">
            <summary>
            Sandbox.ClientEntity.InternalStartTouch( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalOnTouch(System.UInt32,System.UInt32)">
            <summary>
            Sandbox.ClientEntity.InternalOnTouch( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalEndTouch(System.UInt32,System.UInt32)">
            <summary>
            Sandbox.ClientEntity.InternalEndTouch( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalOnParentChanged(System.UInt32,System.UInt32)">
            <summary>
            Sandbox.ClientEntity.InternalOnParentChanged( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalPreDataUpdate(System.UInt32)">
            <summary>
            Sandbox.ClientEntity.InternalPreDataUpdate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalPostDataUpdate(System.UInt32,System.Int32)">
            <summary>
            Sandbox.ClientEntity.InternalPostDataUpdate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalNetworkVariableChanged(System.UInt32,System.Int32,System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Sandbox.ClientEntity.InternalNetworkVariableChanged( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalOnNewModel(System.UInt32)">
            <summary>
            Sandbox.ClientEntity.InternalOnNewModel( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalAnimEvent(System.UInt32,System.IntPtr,System.Int32,System.Single,Vector3,System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalAnimEvent( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalAnimEventFootstep(System.UInt32,Vector3,System.Int32,System.Single)">
            <summary>
            Sandbox.ClientEntity.InternalAnimEventFootstep( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalPostClientActive(System.UInt32)">
            <summary>
            Sandbox.ClientEntity.InternalPostClientActive( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalOnSequenceFinished(System.UInt32,System.Int32)">
            <summary>
            Sandbox.ClientEntity.InternalOnSequenceFinished( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalOnNewSequence(System.UInt32)">
            <summary>
            Sandbox.ClientEntity.InternalOnNewSequence( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_PredictionStore(System.UInt32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sandbox.ClientEntity.PredictionStore( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_PredictionRestore(System.UInt32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sandbox.ClientEntity.PredictionRestore( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_PredictionVerify(System.UInt32,System.Int32,System.Int32)">
            <summary>
            Sandbox.ClientEntity.PredictionVerify( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_PredictionDestroy(System.UInt32)">
            <summary>
            Sandbox.ClientEntity.PredictionDestroy( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_PredictionShift(System.UInt32,System.Int32)">
            <summary>
            Sandbox.ClientEntity.PredictionShift( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalMoveDone(System.UInt32)">
            <summary>
            Sandbox.ClientEntity.InternalMoveDone( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalMoveBlocked(System.UInt32,System.UInt32)">
            <summary>
            Sandbox.ClientEntity.InternalMoveBlocked( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalOnSetDormant(System.UInt32,System.Int32)">
            <summary>
            Sandbox.ClientEntity.InternalOnSetDormant( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalPhysicsCollisionEvent(System.UInt32,System.UInt32,Vector3,Vector3,Vector3,Vector3,Vector3,Vector3,System.Single)">
            <summary>
            Sandbox.ClientEntity.InternalPhysicsCollisionEvent( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_PlayerSetupVisibility(System.UInt32,System.Int32,System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.PlayerSetupVisibility( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalOnAnimGraphTag(System.UInt32,System.IntPtr,System.Int32)">
            <summary>
            Sandbox.ClientEntity.InternalOnAnimGraphTag( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalOnAnimGraphCreated(System.UInt32)">
            <summary>
            Sandbox.ClientEntity.InternalOnAnimGraphCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_ClentE_InternalOnNameChanged(System.UInt32,System.IntPtr)">
            <summary>
            Sandbox.ClientEntity.InternalOnNameChanged( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_CnsleS_DispatchCommand(System.IntPtr,System.IntPtr,System.Int64,System.Int32)">
            <summary>
            Sandbox.ConsoleSystem.DispatchCommand( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_OnNativeEntity(System.UInt32,System.IntPtr)">
            <summary>
            Sandbox.Entity.OnNativeEntity( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalDestruct(System.UInt32)">
            <summary>
            Sandbox.Entity.InternalDestruct( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalUpdateOnRemove(System.UInt32)">
            <summary>
            Sandbox.Entity.InternalUpdateOnRemove( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_EnterPVSInternal(System.UInt32)">
            <summary>
            Sandbox.Entity.EnterPVSInternal( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_LeavePVSInternal(System.UInt32)">
            <summary>
            Sandbox.Entity.LeavePVSInternal( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalClientCreated(System.UInt32)">
            <summary>
            Sandbox.Entity.InternalClientCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalClientActivate(System.UInt32)">
            <summary>
            Sandbox.Entity.InternalClientActivate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalEntityKeyValue(System.UInt32,System.UInt32,System.IntPtr,System.Int32)">
            <summary>
            Sandbox.Entity.InternalEntityKeyValue( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalEntityConnection(System.UInt32,System.IntPtr,System.Int64,System.IntPtr,System.IntPtr,System.IntPtr,System.Single,System.Int32)">
            <summary>
            Sandbox.Entity.InternalEntityConnection( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalSpawn(System.UInt32)">
            <summary>
            Sandbox.Entity.InternalSpawn( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalStartTouch(System.UInt32,System.UInt32)">
            <summary>
            Sandbox.Entity.InternalStartTouch( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalOnTouch(System.UInt32,System.UInt32)">
            <summary>
            Sandbox.Entity.InternalOnTouch( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalEndTouch(System.UInt32,System.UInt32)">
            <summary>
            Sandbox.Entity.InternalEndTouch( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalOnParentChanged(System.UInt32,System.UInt32)">
            <summary>
            Sandbox.Entity.InternalOnParentChanged( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalPreDataUpdate(System.UInt32)">
            <summary>
            Sandbox.Entity.InternalPreDataUpdate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalPostDataUpdate(System.UInt32,System.Int32)">
            <summary>
            Sandbox.Entity.InternalPostDataUpdate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalNetworkVariableChanged(System.UInt32,System.Int32,System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Sandbox.Entity.InternalNetworkVariableChanged( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalOnNewModel(System.UInt32)">
            <summary>
            Sandbox.Entity.InternalOnNewModel( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalAnimEvent(System.UInt32,System.IntPtr,System.Int32,System.Single,Vector3,System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalAnimEvent( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalAnimEventFootstep(System.UInt32,Vector3,System.Int32,System.Single)">
            <summary>
            Sandbox.Entity.InternalAnimEventFootstep( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalPostClientActive(System.UInt32)">
            <summary>
            Sandbox.Entity.InternalPostClientActive( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalOnSequenceFinished(System.UInt32,System.Int32)">
            <summary>
            Sandbox.Entity.InternalOnSequenceFinished( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalOnNewSequence(System.UInt32)">
            <summary>
            Sandbox.Entity.InternalOnNewSequence( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_PredictionStore(System.UInt32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sandbox.Entity.PredictionStore( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_PredictionRestore(System.UInt32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sandbox.Entity.PredictionRestore( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_PredictionVerify(System.UInt32,System.Int32,System.Int32)">
            <summary>
            Sandbox.Entity.PredictionVerify( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_PredictionDestroy(System.UInt32)">
            <summary>
            Sandbox.Entity.PredictionDestroy( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_PredictionShift(System.UInt32,System.Int32)">
            <summary>
            Sandbox.Entity.PredictionShift( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalMoveDone(System.UInt32)">
            <summary>
            Sandbox.Entity.InternalMoveDone( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalMoveBlocked(System.UInt32,System.UInt32)">
            <summary>
            Sandbox.Entity.InternalMoveBlocked( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalOnSetDormant(System.UInt32,System.Int32)">
            <summary>
            Sandbox.Entity.InternalOnSetDormant( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalPhysicsCollisionEvent(System.UInt32,System.UInt32,Vector3,Vector3,Vector3,Vector3,Vector3,Vector3,System.Single)">
            <summary>
            Sandbox.Entity.InternalPhysicsCollisionEvent( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_PlayerSetupVisibility(System.UInt32,System.Int32,System.IntPtr)">
            <summary>
            Sandbox.Entity.PlayerSetupVisibility( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalOnAnimGraphTag(System.UInt32,System.IntPtr,System.Int32)">
            <summary>
            Sandbox.Entity.InternalOnAnimGraphTag( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalOnAnimGraphCreated(System.UInt32)">
            <summary>
            Sandbox.Entity.InternalOnAnimGraphCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Entity_InternalOnNameChanged(System.UInt32,System.IntPtr)">
            <summary>
            Sandbox.Entity.InternalOnNameChanged( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_EnttyM_CreateServerEntity(System.IntPtr)">
            <summary>
            Sandbox.EntityManager.CreateServerEntity( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_EnttyM_CreateClientsideOfNetworkedEntity(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.EntityManager.CreateClientsideOfNetworkedEntity( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_Init">
            <summary>
            Sandbox.GameLoop.Init( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_PreOnActivate">
            <summary>
            Sandbox.GameLoop.PreOnActivate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_PostOnActivate">
            <summary>
            Sandbox.GameLoop.PostOnActivate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_OnDeactivate">
            <summary>
            Sandbox.GameLoop.OnDeactivate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_LoopShutdown">
            <summary>
            Sandbox.GameLoop.LoopShutdown( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_ClientPutInServer(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Sandbox.GameLoop.ClientPutInServer( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_ClientDisconnected(System.Int32,System.Int32,System.IntPtr,System.UInt64,System.IntPtr)">
            <summary>
            Sandbox.GameLoop.ClientDisconnected( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_OnClientPreOutput">
            <summary>
            Sandbox.GameLoop.OnClientPreOutput( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_OnClientPostOutput">
            <summary>
            Sandbox.GameLoop.OnClientPostOutput( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_NotifyDisconnect(System.Int32,System.IntPtr)">
            <summary>
            Sandbox.GameLoop.NotifyDisconnect( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_GetView(System.IntPtr)">
            <summary>
            Sandbox.GameLoop.GetView( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_PreRender">
            <summary>
            Sandbox.GameLoop.PreRender( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_UpdateAudioListener(System.IntPtr)">
            <summary>
            Sandbox.GameLoop.UpdateAudioListener( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_PhysicsThink">
            <summary>
            Sandbox.GameLoop.PhysicsThink( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_PrePhysicsStep(System.Single)">
            <summary>
            Sandbox.GameLoop.PrePhysicsStep( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_PostPhysicsStep(System.Single)">
            <summary>
            Sandbox.GameLoop.PostPhysicsStep( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_PhysicsImpactSound(System.Int32,Vector3,System.Single,System.Single,System.Int32,System.Int32)">
            <summary>
            Sandbox.GameLoop.PhysicsImpactSound( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_OnPhysicsJointBreak(System.Int32)">
            <summary>
            Sandbox.GameLoop.OnPhysicsJointBreak( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_RunBotCommands">
            <summary>
            Sandbox.GameLoop.RunBotCommands( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_ServerFrame_Think">
            <summary>
            Sandbox.GameLoop.ServerFrame_Think( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_ClientFrame_Think">
            <summary>
            Sandbox.GameLoop.ClientFrame_Think( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_PostEntitySpawn">
            <summary>
            Sandbox.GameLoop.PostEntitySpawn( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_Server_GetTimeScale">
            <summary>
            Sandbox.GameLoop.Server_GetTimeScale( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_Server_GetTickRate">
            <summary>
            Sandbox.GameLoop.Server_GetTickRate( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_OnFrameSimulateStart">
            <summary>
            Sandbox.GameLoop.OnFrameSimulateStart( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_OnFrameSimulateEnd">
            <summary>
            Sandbox.GameLoop.OnFrameSimulateEnd( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_GameLo_OnModelReloaded(System.IntPtr)">
            <summary>
            Sandbox.GameLoop.OnModelReloaded( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Netwrk_OnNetMessage(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Sandbox.Networking.OnNetMessage( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_PlyerC_RunClient(System.UInt32,System.IntPtr)">
            <summary>
            Sandbox.PlayerCommand.RunClient( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_PlyerC_RunClientFrame(System.IntPtr)">
            <summary>
            Sandbox.PlayerCommand.RunClientFrame( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_PlyerC_RunServer(System.UInt32,System.IntPtr)">
            <summary>
            Sandbox.PlayerCommand.RunServer( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_RelTme_Update(System.Single)">
            <summary>
            Sandbox.RealTime.Update( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandboserver_Physcs_OnObjectCreated(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.PhysicsBody.OnObjectCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandboserver_Physcs_OnObjectDestroyed(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.PhysicsBody.OnObjectDestroyed( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandboserver_Physcs_f2(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.PhysicsGroup.OnObjectCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandboserver_Physcs_f3(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.PhysicsGroup.OnObjectDestroyed( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandboserver_Physcs_f4(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.PhysicsJoint.OnObjectCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandboserver_Physcs_f5(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.PhysicsJoint.OnObjectDestroyed( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandboserver_Physcs_f6(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.PhysicsShape.OnObjectCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandboserver_Physcs_f7(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.PhysicsShape.OnObjectDestroyed( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandboserver_SceneO_OnObjectCreated(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.SceneObject.OnObjectCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandboserver_SceneO_OnObjectDestroyed(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.SceneObject.OnObjectDestroyed( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandboserver_SceneW_OnObjectCreated(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.SceneWorld.OnObjectCreated( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandboserver_SceneW_OnObjectDestroyed(System.IntPtr,System.Int32)">
            <summary>
            Sandbox.SceneWorld.OnObjectDestroyed( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_StrngT_Init">
            <summary>
            Sandbox.StringTables.Init( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_StrngT_Shutdown">
            <summary>
            Sandbox.StringTables.Shutdown( ... )
            </summary>
        </member>
        <member name="M:Managed.SourceServer.Exports.Sandbo_Time_Update(System.Single,System.Single,System.Int32)">
            <summary>
            Sandbox.Time.Update( ... )
            </summary>
        </member>
    </members>
</doc>
